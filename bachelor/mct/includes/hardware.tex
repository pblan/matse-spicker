\section{Hardware-Software Schnittstelle}

\begin{defi}{Transistor}
    \emph{TRANsfer reSISTOR (Transistor)} bedeutet soviel wie \enquote{steuerbarer Widerstand}.

    Im Kontext der Digitaltechnik reicht uns die einfache Vorstellung eines CMOS-Transistors als durch Spannung gesteuerte Schalter.
    Sie bestehen aus \emph{Emitter}, \emph{Collector} und \emph{Base}.

    \begin{minipage}[t]{0.45\textwidth}
        Der \emph{n-Typ} Transistor schließt, wenn an der Base 3.3V anliegt.

        \begin{center}
            \includegraphics[width=0.5\textwidth]{includes/figures/defi_npn.pdf}
        \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.1\textwidth}
        \
    \end{minipage}
    \begin{minipage}[t]{0.45\textwidth}
        Der \emph{p-Typ} Transistor schließt, wenn an der Base 0V anliegt.

        \begin{center}
            \includegraphics[width=0.5\textwidth]{includes/figures/defi_pnp.pdf}
        \end{center}
    \end{minipage}
\end{defi}

\begin{defi}{Logikgatter mit Transistoren}
    \begin{minipage}[t]{0.33\textwidth}
        \begin{center}
            \emph{NICHT (NOT)}
        \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.33\textwidth}
        \begin{center}
            \emph{UND (AND)}
        \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.33\textwidth}
        \begin{center}
            \emph{ODER (OR)}
        \end{center}
    \end{minipage}

    \includegraphics[width=\textwidth]{includes/figures/defi_logikgatter.pdf}

    \begin{minipage}[t]{0.33\textwidth}
        \begin{center}
            \begin{tabular}{|c||c|}
                \hline
                $A$ & $\bar{A}$ \\\hline\hline
                0   & 1         \\\hline
                1   & 0         \\\hline
            \end{tabular}
        \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.33\textwidth}
        \begin{center}
            \begin{tabular}{|c|c||c|}
                \hline
                $A$ & $B$ & $A \land B$ \\\hline\hline
                0   & 0   & 0           \\\hline
                0   & 1   & 0           \\\hline
                1   & 0   & 0           \\\hline
                1   & 1   & 1           \\\hline
            \end{tabular}
        \end{center}
    \end{minipage}
    \begin{minipage}[t]{0.33\textwidth}
        \begin{center}
            \begin{tabular}{|c|c||c|}
                \hline
                $A$ & $B$ & $A \lor B$ \\\hline\hline
                0   & 0   & 0          \\\hline
                0   & 1   & 1          \\\hline
                1   & 0   & 1          \\\hline
                1   & 1   & 1          \\\hline
            \end{tabular}
        \end{center}
    \end{minipage}
\end{defi}

\begin{bonus}{Logikgatter mit Transistoren}
    Da \emph{AND} und \emph{OR} am Ende negiert werden müssen, sind \emph{NAND} und \emph{NOR} \enquote{leichter} zu bauen:

    \begin{center}
        \begin{minipage}[t]{0.33\textwidth}
            \begin{center}
                \emph{NAND}
            \end{center}
        \end{minipage}
        \begin{minipage}[t]{0.33\textwidth}
            \begin{center}
                \emph{NOR}
            \end{center}
        \end{minipage}

        \includegraphics[width=0.66\textwidth]{includes/figures/bonus_logikgatter.pdf}

        \begin{minipage}[t]{0.33\textwidth}
            \begin{center}
                \begin{tabular}{|c|c||c|c|}
                    \hline
                    $A$ & $B$ & $A \land B$ & $\lnot (A \land B)$ \\\hline\hline
                    0   & 0   & 0           & 1                   \\\hline
                    0   & 1   & 0           & 1                   \\\hline
                    1   & 0   & 0           & 1                   \\\hline
                    1   & 1   & 1           & 0                   \\\hline
                \end{tabular}
            \end{center}
        \end{minipage}
        \begin{minipage}[t]{0.33\textwidth}
            \begin{center}
                \begin{tabular}{|c|c||c|c|}
                    \hline
                    $A$ & $B$ & $A \lor B$ & $\lnot (A \lor B)$ \\\hline\hline
                    0   & 0   & 0          & 1                  \\\hline
                    0   & 1   & 1          & 0                  \\\hline
                    1   & 0   & 1          & 0                  \\\hline
                    1   & 1   & 1          & 0                  \\\hline
                \end{tabular}
            \end{center}
        \end{minipage}
    \end{center}
\end{bonus}

\begin{defi}{Treiber}
    \begin{center}
        \emph{Treiber (Three-State Driver)}
    \end{center}

    \begin{minipage}{0.5\textwidth}
        \begin{center}
            \includegraphics[width=0.66\textwidth]{includes/figures/defi_driver.pdf}
        \end{center}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \begin{center}
            \includegraphics[width=0.4\textwidth]{includes/figures/defi_driver_symbol.pdf}

            \begin{tabular}{|c|c||c|}
                \hline
                $A$ & $\bar{G}$ & $Y$ \\\hline\hline
                0   & 0         & 0   \\\hline
                0   & 1         & nc  \\\hline
                1   & 0         & 1   \\\hline
                1   & 1         & nc  \\\hline
            \end{tabular}
        \end{center}
    \end{minipage}

    \footnotetext[1]{\enquote{not connected bzw. dritter hochohmiger Zustand}}
\end{defi}

\begin{defi}{Multiplexer}
    Ein \emph{Multiplexer} wird genutzt, um an einen Ausgang mehrere Eingänge anzuschließen, die einzeln weitergeleitet werden.

    $S_1$ und $S_2$ steuern dabei die Eingänge $A$ bis $D$.

    \begin{minipage}{0.5\textwidth}
        \begin{center}
            \includegraphics[width=0.3\textwidth]{includes/figures/defi_multiplexer.pdf}
        \end{center}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \begin{center}
            \begin{tabular}{|c|c|c|c|c|c||c|c|}
                \hline
                $A$ & $B$ & $C$ & $D$ & $S_1$ & $S_2$ & $Y$ & $Y$ \\\hline\hline
                0   & *   & *   & *   & 0     & 0     & $A$ & 0   \\\hline
                1   & *   & *   & *   & 0     & 0     & $A$ & 1   \\\hline
                *   & 0   & *   & *   & 0     & 1     & $B$ & 0   \\\hline
                *   & 1   & *   & *   & 0     & 1     & $B$ & 1   \\\hline
                *   & *   & 0   & *   & 1     & 0     & $C$ & 0   \\\hline
                *   & *   & 1   & *   & 1     & 0     & $C$ & 1   \\\hline
                *   & *   & *   & 0   & 1     & 1     & $D$ & 0   \\\hline
                *   & *   & *   & 1   & 1     & 1     & $D$ & 1   \\\hline
            \end{tabular}
        \end{center}
    \end{minipage}
\end{defi}

\begin{defi}{SR-Latch}
    Ein \emph{SR-Latch} wird genutzt, um eine kurze anliegende Flanke ($S$) zu halten.

    $R$ wird genutzt, um den SR-Latch zu resetten.

    \begin{center}
        \includegraphics[width=0.5\textwidth]{includes/figures/defi_sr_latch.pdf}
    \end{center}
\end{defi}

\begin{bonus}{SR-Latch Übergänge}
    \begin{center}
        \includegraphics[width=0.75\textwidth]{includes/figures/bonus_sr_latch.pdf}
    \end{center}
\end{bonus}

\begin{defi}{SR-Latch mit Takt}
    Durch die UND-Gatter werden die Set und Reset-Signale nur weitergeleitet, wenn das Clock-Signal \texttt{HIGH} ist.

    \begin{center}
        \includegraphics[width=0.75\textwidth]{includes/figures/defi_lr_latch_clock.pdf}
    \end{center}

    Alternativ kann man das Reset Signal mit \texttt{NOT-Set} ersetzen:

    \begin{center}
        \includegraphics[width=0.75\textwidth]{includes/figures/defi_lr_latch_clock2.pdf}
    \end{center}
\end{defi}

\begin{defi}{Pulsgenerator}
    Häufig soll die Datenübernahme nur bei einer steigenden oder fallenden Flanke des Clock-Signals erfolgen.
    Dazu wird ein \emph{Pulsgenerator} eingesetzt.

    Sei $\Delta$ die Verzögerung, die die Bauteile zum \enquote{schalten} benötigen:

    \begin{center}
        \includegraphics[width=0.75\textwidth]{includes/figures/defi_pulsgenerator.pdf}
    \end{center}
\end{defi}

\begin{defi}{D-Flipflop}
    Ein \emph{D-Flipflop} kombiniert das D-Latch mit einer Flankensteuerung:

    \begin{center}
        \includegraphics[width=0.75\textwidth]{includes/figures/defi_d_flipflop.pdf}
    \end{center}
\end{defi}

\begin{defi}{MSP432 Speicher Layout}
    ARM Prozessoren nutzen die Harvard-Architektur.
    Der MSP432 besitzt 32-Bit Adressbusse und 32-Bit Datenbusse.

    Aus der Programmierperspektive zeigt jede Adresse jedoch auf einen Byte (8 bit), nicht ein ganzes 32-Bit Wort.

    Der MSP432 hat einen 4GB großen Adressraum, der in 512MB große Zonen unterteilt ist:

    \includegraphics[width=\textwidth]{includes/figures/defi_msp432_speicher.pdf}
\end{defi}

\begin{defi}{GPIO-Register}
    \begin{wrapfigure}{r}{0.35\textwidth}
        \begin{center}
            \includegraphics[width=0.3\textwidth]{includes/figures/defi_msp432_port.pdf}
        \end{center}
    \end{wrapfigure}
    %
    Die Einstellungen für einen GPIO-Port\footnote{
        Wiederholung: Ein Port beinhaltet 8 Leitungen zu GPIO-Pins, die nach außen Kommunizieren.
        In folgenden Beispielen wird \texttt{Port 1.0} genutzt.
    } befinden sich in mehreren Registern.
    Sie sind in folgende Register unterteilt:
    \begin{itemize}
        \item \texttt{SEL1}: Select1
        \item \texttt{SEL2}: Select2
        \item \texttt{REN}: Resistor Enable
        \item \texttt{DIR}: Richtung (Direction)
        \item \texttt{OUT}: Ausgangspegel
        \item \texttt{IN}: Eingangspegel
    \end{itemize}
\end{defi}

\begin{bonus}{MSP432 Implementierung}
    Um einen GPIO-Pin auf \texttt{INPUT} zu setzen, muss \texttt{PxDIR} auf \texttt{1} gesetzt werden.

    Für einen digitalen Ausgang, kann man \texttt{PxSEL0} und \texttt{PxSEL1} z. B. auf \texttt{0} setzen.

    Um einen GPIO-Pin auf \texttt{OUTPUT} zu setzen, muss \texttt{PxDIR} auf \texttt{0} gesetzt werden.

    Für einen Pullup Widerstand muss man z. B. \texttt{PxSEL0} und \texttt{PxSEL1} z. B. auf \texttt{0} setzen.
\end{bonus}

\begin{bonus}{Bitmaske}
    Man kann durch die \texttt{msp.h} Bibliothek byteweise auf Register zugreifen.
    Jedoch möchte man anliegende Leitungen nicht durch Operationen beeinflussen.

    Dazu kann man durch logische Verknüpfungen einzelne Bits verändern.

    Sei P1 bis auf das letzte bit (\texttt{$\alpha$}) unbekannt, die Maske für P1.1 sei \texttt{0000 0001}:

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            $\text{P1} \land \text{Maske}$ & $\text{P1} \land \lnot \text{Maske}$ & $\text{P1} \lor \text{Maske}$ & $\text{P1} \lor \lnot \text{Maske}$ & $\text{P1} \oplus \text{Maske}$ \\\hline\hline
            \texttt{0000 0000$\alpha$}     & \texttt{.... ...0}                   & \texttt{.... ...1}            & \texttt{1111 1111$\alpha$}          & \texttt{.... ...$\lnot \alpha$} \\\hline
        \end{tabular}
    \end{center}

    Wir sehen, dass wir um $\alpha$ zu verändern folgende Verknüpfungen nehmen müssen:

    \begin{tabular}{cc}
        \texttt{0}:              & $\land \lnot (\text{0000 0001})$ \\
        \texttt{1}:              & $\lor (\text{0000 0001})$        \\
        \texttt{$\lnot \alpha$}: & $\oplus (\text{0000 0001})$      \\
    \end{tabular}
\end{bonus}

\begin{example}{C-Schnittstelle zur Peripherie}
    Wenn wir \texttt{P1.0}\footnote{Auf dem MSP432 die rote LED} als Output setzen wollen, können wir die Register wie folgt manipulieren:

    \begin{lstlisting}[language=c]
        #include msp.h
        #define BIT0 (uint16_t) (0x0001) // 0000 0001

        // Select GPIO mode
        P1->SEL0 &= ~BIT0 // .... ...0
        P1->SEL1 &= ~BIT0 // .... ...0

        // Set as output
        P1->DIR |= BIT0   // .... ...1

        // Modify output
        P1->OUT &= ~BIT0  // .... ...0 - Clear P1.0
        P1->OUT |= BIT0   // .... ...1 - Set P1.0
        P1->OUT ^= BIT0   // TOGGLE P1.0
    \end{lstlisting}
\end{example}

\begin{example}{C-Schnittstelle zur Peripherie}
    Wenn wir P5.1\footnote{Auf dem MSP432 Schalter 1} als Input setzen wollen, können wir die Register wie folgt manipulieren:

    \begin{lstlisting}[language=c]
        #include msp.h
        #define BIT1 (uint16_t) (0x0002) // 0000 0010

        // Select GPIO mode
        P5->SEL0 &= ~BIT1 // .... ...0
        P5->SEL1 &= ~BIT1 // .... ...0

        // Set as input
        P5->DIR &= ~BIT1  // .... ...0

        // Read P5
        P5->IN
    \end{lstlisting}
\end{example}