\section{Bäume}

\begin{defi}{Baum}
    Ein \emph{Baum} ist eine hierarchische (rekursive) Datenstruktur.
    Es gilt:
    \begin{itemize}
        \item alle Wege gehen von einer \emph{Wurzel} aus
        \item $A$ heißt \emph{Vorgänger} von $B$ bzw. $B$ \emph{Nachfolger} von $A$, wenn $A$ auf einem Weg von der Wurzel zu $B$ liegt
        \item $A$ heißt \emph{Elterknoten} von $B$, bzw. $B$ heißt \emph{Kind} von $A$, wenn $(A, B) \in E$
        \item Knoten ohne Kinder heißen \emph{Blätter}
        \item Knoten mit Kindern heißen \emph{innere Knoten}
        \item ein Knoten $S$ mit allen Nachfolgern wird \emph{Teilbaum} eines Baumes $T$ genannt, falls $S$ nicht Wurzel von $T$ ist
        \item der \emph{Verzweigungsgrad} eines Knotens ist die Anzahl seiner Kinder
    \end{itemize}

    \vspace{1em}

    \begin{center}
        \begin{forest}
            for tree={s sep=5mm, fit=band}
            [Wurzel, name=root
            [Blatt, name=blatt1]
            [Innerer Knoten, name=inner1 [Blatt, name=blatt2]
            [Innerer Knoten, name=inner2
            [Blatt, name=blatt3]
            [Innerer Knoten, name=inner3 [Blatt, name=blatt4]
            [Blatt, name=blatt5]]]]]
            \node [draw, label=left:Level 0, dashed, fit={(root) (blatt1.west |- root.center) (inner3.east |- root.center)}] {};
            \node [draw, label=left:Level 1, dashed, fit={(blatt1) (inner3.east |- blatt1.center)}] {};
            \node [draw, label=left:Level 2, dashed, fit={(blatt2) (blatt1.west |- blatt2.center) (inner3.east |- blatt2.center)}] {};
            \node [draw, label=left:Level 3, dashed, fit={(blatt3) (blatt1.west |- blatt3.center) (inner3)}] {};
            \node [draw, label=left:Level 4, dashed, fit={(blatt4) (blatt1.west |- blatt5.center) (blatt5) (inner3.east |- blatt5.center)}] {};
            \node [draw, red, fit={(inner2) (inner3) (blatt5) (blatt3)},label=right:{\color{red}Teilbaum}] {};
        \end{forest}
    \end{center}
\end{defi}

% Binärbäume

\begin{defi}{Binärbaum}
    Die Knoten eines \emph{Binärbaums (binary tree)} haben höchstens den Verzweigungsgrad $2$.

    Bei einem \emph{geordneten Binärbaum} ist die Reihenfolge der Kinder durch die Indizes eindeutig festgelegt:
    \begin{itemize}
        \item $T_l$: linkes Kind, linker Teilbaum
        \item $T_r$: rechtes Kind, rechter Teilbaum
    \end{itemize}

    Ein Binärbaum heißt \emph{minimal} (bezogen auf die Höhe), wenn kein Binärbaum mit gleicher Knotenzahl aber kleinerer Höhe existiert.

    Ein \emph{links-vollständiger Binärbaum} ist ein minimaler Binärbaum, in dem die Knoten auf dem untersten Level so weit wie möglich links stehen.

    Alle Blätter eines \emph{vollständigen Binärbaums} haben den gleichen Level und dieser ist vollbesetzt.

    Ein vollständiger Binärbaum der Höhe $H$ hat
    $$
        n = 1 + 2 + 4 + \ldots + 2^H = \frac{2^{H+1}-1}{2-1} = 2^{H+1}-1 \ \text{Knoten}
    $$
\end{defi}

\begin{halfboxl}
    \begin{example}{Linksvollständiger Binärbaum}
        \centering
        \begin{forest}
            for tree={circle, draw,
            minimum size=1.75em, % <-- added
            inner sep=1pt}
            [
            [
                    [
                            []
                                []
                        ]
                        [
                            []
                                []
                        ]
                ]
                [
                    []
                        []
                ]
            ]
        \end{forest}
    \end{example}
\end{halfboxl}
\begin{halfboxr}
    \begin{example}{Vollständiger Binärbaum}
        \centering
        \begin{forest}
            for tree={circle, draw,
            minimum size=1.75em, % <-- added
            inner sep=1pt}
            [
            [
                    [
                            []
                                []
                        ]
                        [
                            []
                                []
                        ]
                ]
                [
                    [
                            []
                                []
                        ]
                        [
                            []
                                []
                        ]
                ]
            ]
        \end{forest}
    \end{example}
\end{halfboxr}

\subsection{Binäre Suchbäume}
% Binäre Suchbäume

\begin{defi}{Binärer Suchbaum}
    Ein \emph{binärer Suchbaum} ist ein Binärbaum, bei dem für jeden Knoten des Baumes gilt:

    Alle Schlüssel im linken Teilbaum sind kleiner, alle im rechten Teilbaum sind größer oder gleich dem Schlüssel in diesem Knoten.
\end{defi}

\begin{algo}{Suchen im binären Suchbaum}
    Suchen ist ohne Probleme durch einfaches Vergleichen ($<$ bzw. $\geq$) möglich.

    Suchen der $50$ in \textcolor{red}{rot} bzw. (erfolgloses) Suchen der $80$ in \textcolor{blue}{blau}.

    \vspace{1em}

    \centering
    \forestset{%
        empty node/.style={dashed}
    }
    \begin{forest}
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [60
        [
        20,edge={->,dashed,red,thick}
        [10 [,empty node][,empty node]]
        [30,edge={->,dashed,red,thick}
        [,empty node]
        [50,edge={->,dashed,red,thick}, draw=red [,empty node][,empty node]]
        ]
        ]
        [
        70,edge={->,dashed,blue,thick}
            [,empty node]
            [110,edge={->,dashed,blue,thick}
                    [90,edge={->,dashed,blue,thick}
                            [,empty node,edge={->,dashed,blue,thick},draw=blue][,empty node]
                    ]
                    [,empty node]
            ]
        ]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Einfügen im binären Suchbaum}
    Ein Knoten kann ohne Probleme hinzugefügt werden, indem man solange sucht, bis man auf einen leeren Kindknoten trifft und dort einfügt.

    Einfügen der $40$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [60
            [
                20,edge={->,dashed,red,thick}
                    [10 [,empty node][,empty node]]
                    [30,edge={->,dashed,red,thick}
                            [,empty node]
                            [50,edge={->,dashed,red,thick} [
                                        40,edge={->,dashed,red,thick},draw=red
                                    ][,empty node]]
                    ]
            ]
            [
                70
                    [,empty node]
                    [110
                            [90
                                    [,empty node][,empty node]
                            ]
                            [,empty node]
                    ]
            ]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen im binären Suchbaum (Blatt)}
    Ein Blatt kann problemlos gelöscht werden.

    Löschen der $50$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20,edge={->,dashed,red,thick}
        [10
            [,empty node]
            [,empty node]
        ]
        [30,edge={->,dashed,red,thick}
        [,empty node]
        [50,edge={->,dashed,red,thick}, draw=red
        [,empty node]
        [,empty node]
        ]
        ]
        ]
    \end{forest}
    \hspace{5em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
            [20
                    [10
                            [,empty node]
                            [,empty node]
                    ]
                    [30
                            [,empty node]
                            [,empty node,draw=red]
                    ]
            ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen im binären Suchbaum (Innerer Knoten mit einem Kind)}
    Soll ein innerer Knoten mit einem Kind gelöscht werden, rückt das Kind an die Stelle des Elterknotens.

    Löschen der $30$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20,edge={->,dashed,red,thick}
        [10
            [,empty node]
            [,empty node]
        ]
        [30,edge={->,dashed,red,thick}, draw=red
        [,empty node]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        {\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vorrücken} (!u.east);}
        ]
        ]
    \end{forest}
    \hspace{5em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20
        [10
            [,empty node]
            [,empty node]
        ]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen im binären Suchbaum (Innerer Knoten mit zwei Kindern)}
    Soll ein innerer Knoten mit zwei Kindern gelöscht werden, nimmt der nächstgrößere Knoten seinen Platz ein.

    Dieser wird wie folgt ermittelt (in \textcolor{purple}{lila}):
    \begin{enumerate}
        \item Gehe einen Schritt nach rechts.
        \item Gehe solange nach links, bis es kein linkes Kind mehr gibt.
    \end{enumerate}

    Löschen der $20$ in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [20,draw=red
        [10
            [,empty node]
            [,empty node]
        ]
        [30,edge={->,dashed,purple,thick},draw=purple
        [,empty node,edge={->,dashed,purple,thick}]
        [50
            [,empty node]
            [,empty node]
        ]
        ]{\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Platz einnehmen} (!u.east);}
        ]
    \end{forest}
    %\hspace{1em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [30,draw=purple
        [10
            [,empty node]
            [,empty node]
        ]
        [,empty node
        %[,empty node]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        {\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vorrücken} (!u.east);}
        ]
        ]
    \end{forest}
    %\hspace{1em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [30,draw=purple
        [10
            [,empty node]
            [,empty node]
        ]
        [50,draw=blue
        [,empty node]
        [,empty node]
        ]
        ]
    \end{forest}
\end{algo}

\begin{bonus}{Komplexität beim Suchen, Löschen und Einfügen in Binärbäumen}
    Die Komplexität der Funktionen Suchen, Löschen und Einfügen werden durch die Komplexität des Suchens eines Elements bestimmt.

    Im schlechtesten Fall ist die Anzahl der zu durchsuchenden Elemente gleich der Höhe des Baumes $+1$.
    Dabei hängt die Höhe stark von der Reihenfolge der Einfügeoperationen ab.

    \vspace{1em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
            [10
                    [,empty node]
                    [
                        20
                            [,empty node]
                            [
                                30
                                    [,empty node]
                                    [
                                        40
                                            [,empty node]
                                            [
                                                50
                                                    [,empty node]
                                                    [
                                                        60
                                                            [,empty node]
                                                            [,empty node]
                                                    ]
                                            ]
                                    ]
                            ]
                    ]
            ]
    \end{forest}
    \hspace{5em}
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
            [
                40
                    [
                        20
                            [
                                10
                                    [,empty node]
                                    [,empty node]
                            ]
                            [
                                30
                                    [,empty node]
                                    [,empty node]
                            ]
                    ]
                    [
                        50
                            [,empty node]
                            [
                                60
                                    [,empty node]
                                    [,empty node]
                            ]
                    ]
            ]
    \end{forest}
\end{bonus}

% Balancierte Bäume

\begin{defi}{Balanciertheit}

    Ein Binärbaum mit $n$ Knoten hat im besten Fall (\emph{optimal balanciert}) die Höhe
    $$
        H = \lceil \log_2(n+1) \rceil - 1 = \lfloor \log_2(n) \rfloor
    $$
    Dabei ist Suchen in $\bigo(\log n)$.

    Ein Binärbaum mit $n$ Knoten hat im schlechtesten Fall (\emph{entartet/degeneriert}) die Höhe
    $$
        H = n-1
    $$
    Dabei ist Suchen in $\bigo(n)$.
\end{defi}

\begin{defi}{Balance-Kriterien}
    \begin{enumerate}
        \item Abgeschwächtes Kriterium für ausgeglichene Höhe
              \begin{itemize}
                  \item lokale Umordnungsoperationen reichen aus
                  \item z.B. \emph{AVL-Bäume} und Rot-Schwarz-Bäume
              \end{itemize}
        \item Jeder neue Knoten wandert an die Wurzel des Baumes
              \begin{itemize}
                  \item Vorteil: Zuletzt eingefügte Elemente lassen sich schneller finden
                  \item durch spezielles Einfügeverfahren wird Baum zusätzlich (teilweise) ausgeglichen
                  \item z.B. Splay-Bäume
              \end{itemize}
        \item Unausgeglichener Verzweigungsgrad ermöglicht ausgeglichene Höhe
              \begin{itemize}
                  \item z.B. \emph{B-Bäume}
              \end{itemize}
    \end{enumerate}
\end{defi}

\subsection{AVL-Bäume}

% AVL-Bäume

\begin{defi}{AVL-Baum}
    Bei einem \emph{AVL-Baum} unterscheiden sich die Höhen zweier Teilbäume des gleichen Knotens maximal um $1$.

    Der sogenannte \emph{Balance-Index} (oder Balance-Faktor) $\BF$ eines Knotens $T$ ist die Differenz
    $$
        \BF(T) := H(T_r) - H(T_l)
    $$
    Dabei gilt:
    \begin{itemize}
        \item Jeder Knoten hat einen Balance-Index.
        \item Er darf nur die Werte $-1$, $0$ oder $1$ annehmen.
    \end{itemize}

    %\vspace{2em}

    \centering
    \begin{forest}
        baseline,anchor=north,
        for tree={circle, draw,
        minimum size=2em, % <-- added
        inner sep=1pt}
        [
        J, label=right:{\small\textcolor{blue}{+1}}
        [
        F, label=right:{\small\textcolor{blue}{-1}}
        [
        D, label=right:{\small\textcolor{blue}{-1}}
        [
        C, label=left:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        [,empty node]
        ]
        [
        G, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        [
        P, label=right:{\small\textcolor{blue}{+1}}
        [
        L, label=right:{\small\textcolor{blue}{+1}}
        [,empty node]
        [
        N, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        [
        V, label=right:{\small\textcolor{blue}{-1}}
        [
        S, label=right:{\small\textcolor{blue}{0}}
        [
        Q, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        [
        U, label=left:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        [
        X, label=right:{\small\textcolor{blue}{0}}
        [,empty node]
        [,empty node]
        ]
        ]
        ]
        ]
    \end{forest}
\end{defi}

\begin{algo}{Einfügen in einem AVL-Baum}
    Beim Einfügen in einen AVL-Baum wird zu Beginn analog zu einem regulären Binärbaum eingefügt.

    Anschließend wird sich der unmittelbare Elterknoten $E$ angeschaut und es gibt für den dortigen Balance-Index $\BF(E)$ drei Fälle:
    \begin{enumerate}
        \item $\BF(E)$ wird $0$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $-1$
                  \item man kommt von einem Kindbaum, der vorher niedriger war
                  \item Höhe des Knotens ändert sich nicht
                  \item oberhalb bleiben alle Balance-Indizes gleich
                  \item $\implies$ AVL-Kriterium ist für den ganzen Baum erfüllt
              \end{itemize}
        \item $\BF(E)$ wird $\pm 1$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $0$
                  \item Höhe des Teilbaums erhöht sich um $1$
                  \item $\implies$ Überprüfung der Balance-Indizes muss beim Elternknoten von $E$ fortgesetzt werden
              \end{itemize}
        \item $\BF(E)$ wird $\pm 2$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $\pm 1$
                  \item $\implies$ Teilbaum muss \emph{rebalanciert} werden
              \end{itemize}
    \end{enumerate}
\end{algo}

\begin{algo}{Löschen in einem AVL-Baum}
    Beim Löschen in einen AVL-Baum wird zu Beginn analog zu einem regulären Binärbaum gelöscht.

    Anschließend wird sich der unmittelbare Elterknoten $E$ angeschaut und es gibt für den dortigen Balance-Index $\BF(E)$ drei Fälle:
    \begin{enumerate}
        \item $\BF(E)$ wird $\pm 1$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $0$
                  \item Höhe des Knotens ändert sich nicht
                  \item oberhalb bleiben alle Balance-Indizes gleich
                  \item $\implies$ AVL-Kriterium ist für den ganzen Baum erfüllt
              \end{itemize}
        \item $\BF(E)$ wird $0$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $0$
                  \item Höhe des Teilbaums verringert sich um $1$
                  \item $\implies$ Überprüfung der Balance-Indizes muss beim Elternknoten von $E$ fortgesetzt werden
              \end{itemize}
        \item $\BF(E)$ wird $\pm 2$:
              \begin{itemize}[-]
                  \item $\BF(E)$ war vorher $\pm 1$
                  \item $\implies$ Teilbaum muss \emph{rebalanciert} werden
              \end{itemize}
    \end{enumerate}
\end{algo}

\begin{algo}{Rebalancierung}
    Wenn bei einer Opeation ein Höhenunterschied von mehr als $1$ zwischen zwei Geschwister-Teilbäumen entsteht, ist beim Elterknoten das AVL-Kriterium verletzt.
    Eine entsprechende Korrektur heißt \emph{Rebalancierung}.
    Als Werkzeuge eignen sich hierfür die sogenannten \emph{Rotationen}.
\end{algo}

\begin{algo}{Einfachrotation}
    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{rechten Teilbaum des rechten Teilbaums} eingefügt wird (Rechts-Rechts-Situation), dann wird das durch eine \emph{Einfachrotation nach links} gelöst.

    Zuletzt wurde $9$ eingefügt. Linksrotation in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [3%, label=right:{\small\textcolor{red}{+2}}
            [1%, label=below right:{\small\textcolor{blue}{0}}
                [,empty node]
                [,empty node]
            ]
            [7, label=above:{\small\textcolor{red}{+2}}, draw=teal, name=7
            [,empty node]
            [8, label=right:{\small\textcolor{blue}{+1}}, draw=purple, edge={teal,thick}
            [,empty node, name=8c]
            [9, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            ]
            ]
            {\draw[->,purple] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
            ]
            ]
            \draw[->,teal] (7) to[bend right=45] (8c);
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [3, label=right:{\small\textcolor{blue}{+1}}
            [1, label=right:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            [8, label=right:{\small\textcolor{blue}{0}}, draw=purple
            [7, label=right:{\small\textcolor{blue}{0}}, draw=teal, edge={teal,thick}
                [,empty node]
                [,empty node]
            ]
            [9, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            ]
            ]
        \end{forest}
    \end{center}

    \vspace{1em}

    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{linken Teilbaum des linken Teilbaums} eingefügt wird (Links-Links-Situation), dann wird das durch eine \emph{Einfachrotation nach rechts} gelöst.

    Zuletzt wurde $1$ eingefügt. Rechtsrotation in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7
            [
            3, label=above:{\small\textcolor{red}{-2}}, draw=teal, name=3
            [
            2, label=left:{\small\textcolor{blue}{-1}}, draw=purple, edge={teal,thick},draw=purple
            [
            1, label=left:{\small\textcolor{blue}{0}}, draw=purple, edge={purple,thick},draw=purple
            ]
            [,empty node, name=2c]
            ]
            {\draw[->,purple] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
            [,empty node]
            ]
            [
            8
                [,empty node]
                [,empty node]
            ]
            ]
            \draw[->,teal] (3) to[bend left=45] (2c);
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7, label=left:{\small\textcolor{blue}{-1}}
            [
            2, label=left:{\small\textcolor{blue}{0}}, draw=purple,draw=purple
            [
            1, label=left:{\small\textcolor{blue}{0}}, draw=purple, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            [3, label=left:{\small\textcolor{blue}{0}}, draw=teal, name=3, edge={teal,thick}
                [,empty node]
                [,empty node]
            ]
            ]
            [
            8, label=left:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            ]
        \end{forest}
    \end{center}
\end{algo}

\begin{algo}{Doppelrotation}
    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{rechten Teilbaum des linken Teilbaums} eingefügt wird, dann wird das durch eine \emph{Doppelrotation} (Linksrotation, gefolgt von Rechtsrotation) gelöst.

    Zuletzt wurde $4$ eingefügt. Rotationen in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7, label=left:{\small\textcolor{red}{-2}}
            [
            3, label=left:{\small\textcolor{blue}{+1}}, draw=teal, name=3
            [,empty node]
            [4, draw=purple, label=right:{\small\textcolor{blue}{0}}, edge={teal,thick},draw=purple
            [,empty node, draw=none, edge={draw=none}, name=4c]
            [,empty node, draw=none, edge={draw=none}]
            ]
            {\draw[->,purple] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
            ]
            [,empty node]
            ]
            \draw[->,teal] (3) to[bend right=45] (4c);
        \end{forest}
        \hspace{-2em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            7, draw=teal, name=7, label=right:{\small\textcolor{red}{-2}}
            [
            4, draw=purple, edge={teal,thick}, label=left:{\small\textcolor{blue}{-1}}
            [
            3, draw=purple, edge={purple,thick}, label=left:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            [,empty node, name=4c]
            ]
            {\draw[->,purple] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
            [,empty node]
            ]
            \draw[->,teal] (7) to[bend left=45] (4c);
        \end{forest}
        \hspace{3em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            4, draw=purple, label=right:{\small\textcolor{blue}{0}}
            [
            3, draw=purple, edge={purple,thick}, label=right:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            [
            7, draw=teal, edge={teal,thick}, label=right:{\small\textcolor{blue}{0}}
            [,empty node]
            [,empty node]
            ]
            ]
        \end{forest}
    \end{center}

    \vspace{1em}

    Wird ein AVL-Baum unbalanciert, wenn ein Knoten in den \emph{linken Teilbaum des rechten Teilbaums} eingefügt wird, dann wird das durch eine \emph{Doppelrotation} (Rechtsrotation, gefolgt von Linksrotation) gelöst.

    Zuletzt wurde $3$ eingefügt. Rotationen in \textcolor{purple}{lila}.

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            2, label=right:{\small\textcolor{red}{+2}}
            [,empty node]
            [
            5, label=right:{\small\textcolor{blue}{-1}}, draw=teal, name=5
            [3, draw=purple, label=left:{\small\textcolor{blue}{0}}, edge={teal,thick},draw=purple
            [,empty node, draw=none, edge={draw=none}]
            [,empty node, draw=none, edge={draw=none}, name=3c]
            ]
            {\draw[->,purple] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
            [,empty node]
            ]
            ]
            \draw[->,teal] (5) to[bend left=45] (3c);
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            2, label=left:{\small\textcolor{red}{+2}}, draw=teal, name=2
            [,empty node]
            [
            3, label=right:{\small\textcolor{blue}{+1}}, draw=purple, edge={teal,thick}
            [,empty node, name=3c]
            [5, draw=purple, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            ]
            {\draw[->,purple] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
            ]
            \draw[->,teal] (2) to[bend right=45] (3c);
        \end{forest}
        \hspace{1em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            3, label=right:{\small\textcolor{blue}{0}},draw=purple
            [
            2, label=right:{\small\textcolor{blue}{0}}, edge={teal,thick},draw=teal
            [,empty node]
            [,empty node]
            ]
            [
            5, label=right:{\small\textcolor{blue}{0}}, edge={purple,thick},draw=purple
            [,empty node]
            [,empty node]
            ]
            ]
        \end{forest}
    \end{center}
\end{algo}


\begin{defi}{Komplexität von AVL-Bäumen}
    \begin{itemize}
        \item Einfügen
              \begin{itemize}
                  \item Element muss gesucht werden: $\bigo(\log n)$
                  \item Element muss angehängt werden: $\bigo(1)$
                  \item Baum muss ausgeglichen werden: $\bigo(\log n)$
              \end{itemize}
        \item Löschen
              \begin{itemize}
                  \item Element muss gesucht werden: $\bigo(\log n)$
                  \item nächstgrößeres Element muss gesucht werden: $\bigo(\log n)$
                  \item Elemente müssen verschoben werden: $\bigo(1)$
                  \item Baum muss ausgeglichen werden: $\bigo(\log n)$\footnote{Im Worst-Case muss für jede Ebene eine Doppelrotation durchgeführt werden $\implies \bigo(\log n)$}
              \end{itemize}
        \item Prüfen/Auslesen
              \begin{itemize}
                  \item Element muss gesucht werden: $\bigo(\log n)$
              \end{itemize}
    \end{itemize}
\end{defi}

\subsection{B-Bäume}
% B-Bäume

\begin{defi}{B-Baum}
    Jeder Knoten in einem \emph{B-Baum der Ordnung d} enthält $d$ bis $2d$ Elemente.

    Die Wurzel bildet die einzige Ausnahme, sie kann $1$ bis $2d$ Elemente enthalten.

    Die Elemente in einem Knoten sind aufsteigend sortiert.

    Die Anzahl der Kinder in einem B-Baum ist entweder $0$ (Blatt) oder um eins größer als die Anzahl der Elemente, die der Knoten enthält.

    Alle Blätter liegen auf demselben Level.
    \begin{itemize}[-]
        \item garantierte Zugriffszeiten
        \item bei realistischen Parametern (z.B. Ordnung $1000$) sind sehr wenige ($<5$) Zugriffe auf das externe Medium nötig
    \end{itemize}

    B-Bäume besitzen ausgeglichene Höhe, lassen aber unausgeglichenen Verzweigungsgrad und Knotenfüllgrad zu.

    Der längste Weg in einem B-Baum der Ordnung $d$ ist in $\bigo(\log_{d+1} n)$.

    B-Baum der Ordnung $2$:
    \vspace{1em}

    \centering
    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=2em,
        }
        [{\mpnc{\textcolor{red}{30}}{\textcolor{violet}{38}}{\textcolor{blue}{42}}{\times}}
            [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{40}{41}{\times}{\times}}, name=c3, edge path={
                        \noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{44}{50}{56}{58}}, name=c4, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
        ]
        \node[fit=(c1), label=below:{$\in [-\infty, \text{\textcolor{red}{30}}]$}] {};
        \node[fit=(c2), label=below:{$\in [\text{\textcolor{red}{30}}, \text{\textcolor{purple}{38}}]$}] {};
        \node[fit=(c3), label=below:{$\in [\text{\textcolor{purple}{38}}, \text{\textcolor{blue}{42}}]$}] {};
        \node[fit=(c4), label=below:{$\in [\text{\textcolor{blue}{42}}, \infty]$}] {};
    \end{forest}
\end{defi}

\begin{algo}{Suchen in einem B-Baum}
    Ausgehend von der Wurzel:
    \begin{enumerate}
        \item Prüfe, ob der gerade betrachtete Knoten den gesuchten Schlüssel $m$ enthält.
              \subitem (Suche innerhalb eines Knotens entweder linear oder binär.)
        \item Falls nicht, bestimme den kleinsten Schlüssel $k_i$, der größer als $m$ ist.
              \begin{itemize}
                  \item $k_i$ gefunden: Weiter bei Schritt 1 mit linkem Kind von $k_i$ ($p_{i-1}$)
                  \item $k_i$ nicht gefunden: Weiter mit letztem Kind ($p_{n}$)
              \end{itemize}
    \end{enumerate}
\end{algo}

\begin{algo}{Einfügen in einem B-Baum der Ordnung $d$}
    \begin{enumerate}
        \item Suche nach Schlüssel endet in einem Blatt \texttt{node} (in \textcolor{purple}{lila})
        \item Schlüssel wird in Sortierreihenfolge eingefügt (und neuer leerer Verweis eingefügt)
        \item Falls \texttt{node} überfüllt ist: \texttt{node} aufteilen
              \subitem $k$ sei mittlerer Eintrag von \texttt{node}
              \begin{enumerate}
                  \item Neuen Knoten \texttt{current} anlegen und mit den $d$ größeren Schlüsseln (rechts von $k$) belegen.
                  \item Die $d$ kleineren Schlüssel (links von $k$) bleiben in \texttt{node}.
                  \item $k$ in Elterknoten \texttt{parent} von \texttt{node} verschieben.
                  \item Verweis rechts von $k$ in \texttt{parent} mit \texttt{current} verbinden.
              \end{enumerate}
        \item Falls \texttt{parent} nun überfüllt ist: \texttt{parent} aufteilen (Siehe Schritt 3)
    \end{enumerate}

    Einfügen der 60 in \textcolor{red}{rot}.

    \vspace{1em}

    \centering
    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{38}{42}{\times}}
            [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{40}{41}{\times}{\times}}, name=c3, edge path={
                        \noexpand\path [draw, \forestoption{edge}] (!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
            [{\mpnc{44}{50}{56}{58}}, name=c4, edge={dashed,purple,thick}, draw=purple, edge path={
                        \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
                    }]
        ]
        \node[draw, above of=c4, rectangle, red, node distance=5em] (60) {60};
        \draw[->, red] (60) to (c4);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{38}{42}{\times}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{40}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, draw=red, edge={draw=none}]
        [{\mpnc{58}{\textcolor{red}{60}}{\times}{\times}}, name=c5, draw=red, edge={draw=none}]
        ]
        \node[draw, above right of=c4, rectangle, blue, node distance=sqrt(2)*4em] (56) {56};
        \draw[->, blue, bend right=15] (56) to (r);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{38}{42}{\textcolor{blue}{56}}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{40}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, draw=red, edge={red}, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{\textcolor{red}{60}}{\times}{\times}}, name=c5, draw=red, edge={red}, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Löschen in einem B-Baum der Ordnung $d$ (Blatt)}
    In einem Blatt mit Struktur
    \begin{center}
        \texttt{(null, $k_1$, null, $\ldots$, $k_i$, null, $\ldots$, $k_n$, null)}
    \end{center}
    (\texttt{null} sind hier die Kinder an der jeweiligen Stelle)
    wird der Wert $x = k_i$ zusammen mit der darauf folgenden \texttt{null}-Referenz gelöscht.

    Ein \emph{Underflow} tritt auf, falls $n=d$ war.
\end{algo}

\begin{algo}{Löschen in einem B-Baum der Ordnung $d$ (Innerer Knoten)}
    In einem inneren Knoten mit Struktur

    \begin{center}
        \texttt{($p_0$, $k_1$, $p_1$, $\ldots$, $k_i$, $p_i$, $\ldots$, $k_n$, $p_n$)}
    \end{center}

    ($p_j$ sind hier die Kinder an der jeweiligen Stelle)
    haben alle Referenzen einen Wert ungleich \texttt{null}.

    Das Löschen eines Wertes $x = k_i$ funktioniert analog zum Löschen aus einem binären Suchbaum:
    \begin{enumerate}
        \item Finde kleinsten Schlüssel $s$ im durch $p_i$ referenzierten Teilbaum (in einem Blatt)
        \item Ersetze $k_i$ durch $s$ und lösche $s$ aus dem Blatt
    \end{enumerate}

    Löschen der 38 in \textcolor{red}{rot}.

    \centering
    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{red}{38}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{40}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\phantom{38}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{\textcolor{blue}{40}}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
        \draw[->, blue] ([xshift=-2.55em] c3.north) to[bend left=15] ([xshift=-0.75em]r.south);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{blue}{40}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\times}{\times}{\times}}, name=c3, draw=purple, label=below:\textcolor{purple}{Underflow!}]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{defi}{Underflow}
    Ein \emph{Underflow} tritt in einem B-Baum genau dann auf, wenn zu wenig ($<d$) Schlüssel im Knoten sind.
\end{defi}

\begin{algo}{Ausgleich zwischen Geschwisterknoten}
    Voraussetzung:
    Knoten $q$ mit Underflow hat \emph{benachbarten} Geschwisterknoten $p$ mit $>d$ Schlüsseln.

    Annahme:
    \begin{itemize}
        \item $p$ ist linker Geschwisterknoten von $q$ (analog mit rechtem Geschwisterknoten)
        \item im Elterknoten \texttt{parent} (von $p$ und $q$) trennt der Schlüssel $t$ die Verweise auf $p$ und $q$
    \end{itemize}

    Idee: $p$ schenkt $q$ ein Element (\glqq Umweg\grqq über Elterknoten)

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{blue}{40}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{\textcolor{blue}{35}}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\times}{\times}{\times}}, name=c3, draw=purple]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
        \draw[->, blue] ([xshift=0.75em] c2.north) to[bend left=90] ([xshift=2.25em] r.north west);
        \draw[<-, blue] ([xshift=-3.4em] c3.north) to[bend right=10] ([xshift=-0.75em] r.south);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{\textcolor{blue}{35}}{42}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{\times}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{\textcolor{blue}{40}}{41}{\times}{\times}}, name=c3]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{algo}{Verschmelzen von Geschwisterknoten}
    Voraussetzung:
    Knoten $q$ hat \emph{benachbarten} Geschwisterknoten mit $d$ Schlüsseln.

    Annahme:
    \begin{itemize}
        \item $p$ ist linker Geschwisterknoten von $q$ (analog mit rechtem Geschwisterknoten)
        \item im Elterknoten \texttt{parent} (von $p$ und $q$) trennt der Schlüssel $t$ die Verweise auf $p$ und $q$
    \end{itemize}

    Idee: $p$ und $q$ mit dem trennenden Element aus \texttt{parent} verschmelzen.

    Beachte:
    \begin{itemize}
        \item Eventueller Underflow in \texttt{parent} muss behandelt werden (rekursiv)
        \item Falls letzter Schlüssel der Wurzel gelöscht wird, wird der einzige Nachfolger der Wurzel die neue Wurzel (Höhe des B-Baums wird um 1 verringert).
    \end{itemize}

    \vspace{1em}

    \centering
    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{40}{\textcolor{blue}{42}}{56}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\times}{\times}{\times}}, name=c3, draw=purple]
        [{\mpnc{44}{50}{\times}{\times}}, name=c4, draw=blue, edge={blue}, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
        \draw[<-, blue] ([xshift=-0.75em] c3.north) to[bend left=10] ([xshift=0.75em] r.south);
        \draw[<-, blue] ([xshift=0.75em] c3.north) to[bend left=45] ([xshift=-3.4em] c4.north);
    \end{forest}

    \vspace{1em}

    \begin{forest}
        for tree = {
        draw,
        rectangle split, rectangle split horizontal,
        rectangle split parts=4,
        %on chain=A,
        parent anchor=south,
        child anchor=north,
        text width=1em,
        text centered,
        %edge = {->},
        l sep=12mm,
        s sep=1em,
        }
        [{\mpnc{30}{40}{56}{\times}}, name=r
        [{\mpnc{10}{20}{25}{\times}}, name=c1, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-3.4em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{32}{34}{35}{\times}}, name=c2, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=-1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        [{\mpnc{41}{\textcolor{blue}{42}}{\textcolor{blue}{44}}{\textcolor{blue}{50}}}, name=c3]
        [{\mpnc{58}{60}{\times}{\times}}, name=c5, edge path={
                \noexpand\path [draw, \forestoption{edge}] ([xshift=1.7em]!u.parent anchor) -- (.child anchor)\forestoption{edge label};
            }]
        ]
    \end{forest}
\end{algo}

\begin{defi}{B+-Baum}
    Im Unterschied zu B-Bäumen speichern \emph{B+-Bäume} ihre Datensätze ausschließlich in den Blättern.

    Dies ist bei der Anwendung für Datenbanken naheliegend und sinnvoll.
\end{defi}

\subsection{Rot-Schwarz-Bäume}

\begin{defi}{Rot-Schwarz-Baum}
    Ein \emph{Rot-Schwarz-Baum} ist ein balancierter binärer Suchbaum, in dem jeder innere Knoten zwei Kinder hat.

    Jeder innere Knoten hat eine Farbe, so dass gilt:
    \begin{itemize}
        \item Die Wurzel ist schwarz.
        \item Alle Blätter (\text{null}-Knoten) sind schwarz.
        \item Für jeden Knoten gilt, dass jeder Pfad zu den Blättern die gleiche Anzahl an schwarzen Knoten hat. (Schwarz-Tiefe)
        \item Beide Kinder eines roten Knotens sind schwarz.
    \end{itemize}

    Rot-Schwarz-Bäume sind eine gängige Alternative zu AVL-Bäumen.
\end{defi}

\begin{algo}{Einfügen in einen Rot-Schwarz-Baum}
    Zuerst wird wie in einem normalen Binärbaum eingefügt, danach werden die Rot-Schwarz-Bedingungen repariert.

    Annahmen:
    \begin{itemize}
        \item eingefügter Knoten $v$ ist rot
        \item Elterknoten $u$ von $v$ ist rot (sonst fertig)
        \item $v$ ist linkes Kind von $u$ (anderer Fall symmetrisch)
        \item Geschwisterknoten $w$ (rechtes Kind von $u$) ist schwarz
        \item Alle roten Knoten außer $u$ haben 2 schwarze Kinder
    \end{itemize}


    \begin{center}

        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            u, r
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                        [
                            q, rbn
                        ]
                ]
        \end{forest}
        \hspace{7em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            q, rbn
                        ]
                        [
                            u, r
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                ]
        \end{forest}
    \end{center}
\end{algo}

\begin{algo}{Einfügen in einen Rot-Schwarz-Baum (Fall 1)}

    \textbf{Fall 1: Onkelknoten $q$ von $v$ ist schwarz}\\
    Fall 1a: $u$ ist linkes Kind von $p$ ($v$-$u$-$p$ bilden eine Linie)
    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            u, r
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                            %{\draw[->,blue, dashed] () to[bend left=30] (!u.south);}
                        ]
                        {\draw[->,blue] () to[bend left=45] node[midway,above left,font=\small]{Rechtsrotation} (!u.west);}
                        [
                            q, b
                        ]
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
        \hspace{3em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    u, r
                        [
                            v, r
                        ]
                        [
                            p, b
                                [
                                    w, b
                                ]
                                [
                                    q, b
                                ]
                        ]
                        {\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Umfärben} (!u.east);}
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
        \hspace{1em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    u, b
                        [
                            v, r
                        ]
                        [
                            p, r
                                [
                                    w, b
                                ]
                                [
                                    q, b
                                ]
                        ]
                    %{\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Umfärben} (!u.east);}
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
    \end{center}

    \vspace{1em}
    Fall 1b: $u$ ist rechtes Kind von $p$ ($v$-$u$-$p$ bilden ein Dreieck)

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            q, b
                        ]
                        [
                            u, r
                                [
                                    v, r
                                ]
                                {\draw[->,blue] () to[bend left=45] node[midway,below left=1em,font=\small]{Rechtsrotation} (!u.west);}
                                [
                                    w, b, name=w
                                ]
                            %{\draw[->,blue, dashed] () to[bend left=30] (!u.south);}
                        ]
                ]
            %{\draw[->,blue, dashed] () to[bend left=45] (w.north east);}
        \end{forest}
        \hspace{5em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, b
                        [
                            q, b
                        ]
                        [
                            v, r
                                [,nil]
                                [
                                    u, r
                                        [,nil]
                                        [
                                            w, b
                                        ]
                                ]
                        ]
                        {\draw[->,blue] () to[bend right=45] node[midway,above right,font=\small]{Linksrotation} (!u.east);}
                ]
        \end{forest}

        \vspace{1em}

        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    v, r
                        [
                            p, b
                                [
                                    q, b
                                ]
                                [, nil]
                        ]
                        {\draw[<->,blue] () to[bend left=45] node[midway,above left,font=\small]{Umfärben} (!u.west);}
                        [
                            u, r
                                [, nil]
                                [
                                    w, b
                                ]
                        ]
                ]
        \end{forest}
        \hspace{2em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    v, b
                        [
                            p, r
                                [
                                    q, b
                                ]
                                [, nil]
                        ]
                        [
                            u, r
                                [, nil]
                                [
                                    w, b
                                ]
                        ]
                ]
        \end{forest}
    \end{center}
\end{algo}

\begin{algo}{Einfügen in einen Rot-Schwarz-Baum (Fall 2)}
    \textbf{Fall 2: Geschwisterknoten $q$ von $u$ ist rot}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            p, b, name=p
            [
            u, r, name=u
            [
            v, r
            ]
            [
            w, b, name=w
            ]
            ]
            [
            q, r, name=q
            ]
            ]
            \node [draw, fit={(p)(u)(q)}, blue, label=above:\textcolor{blue}{Umfärben}] () {};
        \end{forest}
        \hspace{7em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, r
                        [
                            u, b
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                        [
                            q, b
                        ]
                ]
        \end{forest}
    \end{center}

    \vspace{1em}

    beziehungsweise

    \vspace{1em}

    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
            minimum size=2em, % <-- added
            inner sep=1pt}
            [
            p, b, name=p
            [
            q, r, name=q
            ]
            [
            u, r, name=u
            [
            v, r
            ]
            [
            w, b, name=w
            ]
            ]
            ]
            \node [draw, fit={(p)(u)(q)}, blue, label=above:\textcolor{blue}{Umfärben}] () {};
        \end{forest}
        \hspace{7em}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    p, r
                        [
                            q, b
                        ]
                        [
                            u, b
                                [
                                    v, r
                                ]
                                [
                                    w, b, name=w
                                ]
                        ]
                ]
        \end{forest}
    \end{center}

    \vspace{1em}

    \begin{itemize}
        \item Falls der Elterknoten von $p$ schwarz ist, sind wir fertig
        \item Falls $p$ die Wurzel ist, färbe $p$ schwarz
        \item Sonst behandle $p$ wie $v$ und wiederhole
    \end{itemize}
\end{algo}

\begin{algo}{Löschen in einem Rot-Schwarz-Baum}
    Das Löschen in einem Rot-Schwarz-Baum kann schnell sehr schwierig zu visualisieren werden.

    Ich will hier gern einmal folgende Videos empfehlen:
    \begin{itemize}
        \item \url{https://youtu.be/eO3GzpCCUSg} (ausführliche Beispiele, englisch)
        \item \url{https://youtu.be/bDT1woMULVw} (ausführliche Erklärung, Pseudocode, deutsch)
    \end{itemize}
\end{algo}

\subsection{Heaps}

\begin{bonus}{Heap (Wortbedeutungen)}
    Das Wort \emph{Heap} hat zwei Bedeutungen:
    \begin{itemize}
        \item Besonderer Speicherbereich, in dem Objekte und Klassen gespeichert werden.
        \item Datenstruktur zur effizienten Implementierung einer Prioritätswarteschlange.
    \end{itemize}
\end{bonus}

\begin{defi}{Heap}
    Ein \emph{Heap} ist ein Binärbaum mit folgenden Eigenschaften:
    \begin{itemize}
        \item linksvollständig
        \item Kinder eines Knotens höchstens so groß wie der Knoten selbst (Max-Heap)
        \item größtes Element befindet sich an der Wurzel (Max-Heap)
        \item entlang jedes Pfades von einem Knoten zur Wurzel sind Knoteninhalte aufsteigend sortiert
    \end{itemize}

    Ein Heap lässt sich insbesondere als Array sehr leicht speichern.
    Dabei gilt:
    \begin{itemize}
        \item \texttt{heap[0]} ist die Wurzel
        \item \texttt{heap[(i-1)/2]} ist der Elterknoten des Knoten $i$
        \item \texttt{heap[(2*i)+1]} ist das linke Kind des Knoten $i$
        \item \texttt{heap[(2*i)+2]} ist das rechte Kind des Knoten $i$
    \end{itemize}

    Das enstpricht einem Level-Order-Baumdurchlauf.
\end{defi}

\begin{example}{Heap als Array}
    \begin{center}
        \begin{forest}
            baseline,anchor=north,
            for tree={circle, draw,
                    minimum size=2em, % <-- added
                    inner sep=1pt}
                [
                    90
                        [
                            45
                                [
                                    27
                                        [
                                            2
                                        ]
                                        [
                                            3
                                        ]
                                ]
                                [
                                    36
                                        [
                                            19
                                        ]
                                        [26]
                                ]
                        ]
                        [
                            17
                                [
                                    7
                                        [,empty node]
                                        [,empty node]
                                ]
                                [
                                    1
                                        [,empty node]
                                        [,empty node]
                                ]
                        ]
                ]
        \end{forest}
    \end{center}

    \vspace{1em}

    Für den Heap oben gilt die Array-Darstellung:
    \begin{center}
        \texttt{[90,45,17,27,36,7,1,2,3,19,26]}
    \end{center}
\end{example}

\begin{algo}{Einfügen in einem Heap}
    Das Einfügen eines Elements in den Heap erfolgt, indem das neue Element an das Ende des Heaps gesetzt wird.

    Weil das neu eingesetzte Element  die Eigenschaften des Heaps verzerren kann, wird die Operation \emph{Up-Heapify} durchgeführt, um die Eigenschaften des Heaps in einem Bottom-up-Ansatz zu erhalten.
\end{algo}

\begin{algo}{Löschen in einem Heap}
    Das Entfernen eines Elements erfolgt, indem das gelöscht Element durch das letzte Element im Heap ersetzt wird. Dann wird das letzte Element aus dem Heap gelöscht. Nun wird das letzte Element an einer Stelle im Heap platziert.

    Es kann die Heap-Bedingung nicht erfüllen, sodass die Operation \emph{Down-Heapify} durchgeführt wird, um die Eigenschaften des Heaps aufrechtzuerhalten.
\end{algo}

\begin{defi}{Heapify}
    Heapify ist eine Operation, um die Elemente des Heaps neu anzuordnen, um die Heap-Bedingung aufrechtzuerhalten.

    Die Heapify kann in zwei Methoden erfolgen:
    \begin{itemize}
        \item Up-Heapify (erfolgt beim Einfügen)
        \item Down-Heapify (erfolgt beim Löschen)
    \end{itemize}
\end{defi}

\begin{algo}{Up-Heapify (Einfügen)}
    Einfügen der $45$ in \textcolor{red}{rot}.

    \vspace{1em}
    \begin{center}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90
                [
                36
                [
                27
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                26,draw=blue
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [45 ,edge={red,thick}, draw=red]
                {\draw[<->,blue] () to[bend right=45] node[midway,below right,font=\small]{Vertauschen} (!u.east);}
                ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
        \hspace{1em}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90
                [
                36,draw=blue
                [
                27
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                45,edge={red,thick}, draw=red
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [26,edge={teal,thick}, draw=teal]
                ]
                {\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vertauschen} (!u.east);}
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }

        \vspace{1em}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90,draw=teal
                [
                45,edge={teal,thick}, draw=teal
                [
                27
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                36,edge={teal,thick}, draw=teal
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [26,edge={teal,thick}, draw=teal]
                ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
    \end{center}
\end{algo}

\begin{algo}{Down-Heapify (Löschen)}
    Löschen der $90$ in \textcolor{red}{rot}.

    \vspace{1em}
    \begin{center}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                90,draw=red
                [
                45
                    [
                        27
                            [
                                2
                                %[,empty node]
                                %[,empty node]
                            ]
                            [
                                3
                                %[,empty node]
                                %[,empty node]
                            ]
                    ]
                    [
                        36
                            [
                                19
                                %[,empty node]
                                %[,empty node]
                            ]
                            [26
                            ]
                    ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
        \hspace{1em}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                        minimum size=2em, % <-- added
                        inner sep=1pt}
                    [
                        ,empty node, name=90
                            [
                                45
                                    [
                                        27
                                            [
                                                2
                                                %[,empty node]
                                                %[,empty node]
                                            ]
                                            [
                                                3
                                                %[,empty node]
                                                %[,empty node]
                                            ]
                                    ]
                                    [
                                        36
                                            [
                                                19
                                                %[,empty node]
                                                %[,empty node]
                                            ]
                                            [26, draw=blue, name=26
                                            ]
                                    ]
                            ]
                            [
                                17
                                    [
                                        7
                                            [,empty node]
                                            [,empty node]
                                    ]
                                    [
                                        1
                                            [,empty node]
                                            [,empty node]
                                    ]
                            ]
                    ]
                \draw[->, blue] (26) to[bend right=45] node[midway,above left,font=\small]{Nachrücken} (90);
            \end{forest}
        }

        \vspace{1em}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                26, draw=red
                [
                45, edge={draw=red},draw=blue
                [
                27
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                36
                    [
                        19
                        %[,empty node]
                        %[,empty node]
                    ]
                    [,empty node]
                ]
                ]
                {\draw[<->,blue] () to[bend left=45] node[midway,above left,font=\small]{Vertauschen} (!u.west);}
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
        \hspace{1em}
        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                45,draw=teal
                [
                26, draw=red, edge={draw=teal}
                [
                27
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                36, edge={draw=red},draw=blue
                [
                19
                %[,empty node]
                %[,empty node]
                ]
                [,empty node]
                ]
                {\draw[<->,blue] () to[bend right=45] node[midway,above right,font=\small]{Vertauschen} (!u.east);}
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }

        \vspace{1em}

        \scalebox{0.9}{
            \begin{forest}
                baseline,anchor=north,
                for tree={circle, draw,
                minimum size=2em, % <-- added
                inner sep=1pt}
                [
                45,draw=teal
                [
                36, draw=teal, edge={draw=teal}
                [
                27
                    [
                        2
                        %[,empty node]
                        %[,empty node]
                    ]
                    [
                        3
                        %[,empty node]
                        %[,empty node]
                    ]
                ]
                [
                26, edge={draw=teal},draw=teal
                [
                19, edge={draw=teal},draw=teal
                %[,empty node]
                %[,empty node]
                ]
                [,empty node]
                ]
                ]
                [
                17
                    [
                        7
                            [,empty node]
                            [,empty node]
                    ]
                    [
                        1
                            [,empty node]
                            [,empty node]
                    ]
                ]
                ]
            \end{forest}
        }
    \end{center}
\end{algo}

% Baumdurchlauf
