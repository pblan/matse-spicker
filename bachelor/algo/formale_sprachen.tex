\section{Formale Sprachen}
% Textsuche
\subsection{Textsuche}

\begin{bonus}{Textsucheverfahren}
    \begin{itemize}
        \item Naiver, grober, oder brute-force-Algorithmus $\in \bigo(n \cdot m)$
              \begin{itemize}
                  \item für kleine Texte am schnellsten
              \end{itemize}
        \item Knuth-Morris-Pratt, Rabin-Karp $\in \Theta(n + m)$
        \item Boyer-Moore, (Boyer-Moore)-Sunday, (Boyer-Moore)-Horsepool $\in \bigo(n + m)$
              \begin{itemize}
                  \item für große Texte am schnellsten
              \end{itemize}
    \end{itemize}
\end{bonus}

\begin{algo}{Naive Textsuche}
    Bei der \emph{naiven Textsuche} wird an allen Positionen $i$ des Textes nach dem Muster geprüft.

    Die möglichen Positionen reichen von $i=0$ (Muster linksbündig mit dem Text) bis $i = n-m$ (Muster rechtsbündig mit dem Text).

    Das Muster wird an der jeweiligen Position zeichenweise von links nach rechts mit dem Text verglichen.

    Bei einem \emph{Mismatch} oder bei vollständiger Übereinstimmung (\emph{Match}) wird das Muster um eine Position weitergeschoben und an dieser Position verglichen.
\end{algo}

\begin{example}{Naive Textsuche}
    \textbf{Aufgabe:} Finde das Muster \texttt{SINN} im Text \texttt{DASISTSINNLOSERTEXT} mithilfe naiver Textsuche.

    \centering

    \vspace{1em}

    \begin{tikzpicture}[
        start chain,
        node distance = 0pt,
        TextBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
        ]
        { start chain = going right
        %\node [TextBlock, fill=red!50, label=$0$] (0) {};
        \node [TextBlock] (00) {D};
        \node [TextBlock] (01) {A};
        \node [TextBlock] (02) {S};
        \node [TextBlock] (03) {I};
        \node [TextBlock] (04) {S};
        \node [TextBlock] (05) {T};
        \node [TextBlock] (06) {S};
        \node [TextBlock] (07) {I};
        \node [TextBlock] (08) {N};
        \node [TextBlock] (09) {N};
        \node [TextBlock] (10) {L};
        \node [TextBlock] (11) {O};
        \node [TextBlock] (12) {S};
        \node [TextBlock] (13) {E};
        \node [TextBlock] (14) {R};
        \node [TextBlock] (15) {T};
        \node [TextBlock] (16) {E};
        \node [TextBlock] (17) {X};
        \node [TextBlock] (18) {T};


        { [continue chain = going right]
        \chainin (00);

        \node[TextBlock, xshift=-2em, yshift=2em, index] () {\tiny 0};
        \node [TextBlock, index] () {\tiny 1};
        \node [TextBlock, index] () {\tiny 2};
        \node [TextBlock, index] () {\tiny 3};
        \node [TextBlock, index] () {\tiny 4};
        \node [TextBlock, index] () {\tiny 5};
        \node [TextBlock, index] () {\tiny 6};
        \node [TextBlock, index] () {\tiny 7};
        \node [TextBlock, index] () {\tiny 8};
        \node [TextBlock, index] () {\tiny 9};
        \node [TextBlock, index] () {\tiny 10};
        \node [TextBlock, index] () {\tiny 11};
        \node [TextBlock, index] () {\tiny 12};
        \node [TextBlock, index] () {\tiny 13};
        \node [TextBlock, index] () {\tiny 14};
        \node [TextBlock, index] () {\tiny 15};
        \node [TextBlock, index] () {\tiny 16};
        \node [TextBlock, index] () {\tiny 17};
        \node [TextBlock, index] () {\tiny 18};
        }

        { [continue chain = going right]
        \chainin (00);
        \node[TextBlock, xshift=-2em, yshift=-2em, fill=red!50] (1_0) {S};
        \node[TextBlock] (1_1) {I};
        \node[TextBlock] (1_2) {N};
        \node[TextBlock] (1_3) {N};
        %
        \node[on chain, xshift=2em] (1_info) {\texttt{i=0; j=0} $\implies$ Mismatch!};
        }

        { [continue chain = going right]
        \chainin (01);
        \node[TextBlock, xshift=-2em, yshift=-4em, fill=red!50] (1_0) {S};
        \node[TextBlock] (2_1) {I};
        \node[TextBlock] (2_2) {N};
        \node[TextBlock] (2_3) {N};
        %
        \node[on chain, xshift=2em] (1_info) {\texttt{i=1; j=0} $\implies$ Mismatch!};
        }

        { [continue chain = going right]
        \chainin (02);
        \node[TextBlock, xshift=-2em, yshift=-6em, fill=teal!50] (1_0) {S};
        \node[TextBlock, fill=teal!50] (3_1) {I};
        \node[TextBlock, fill=red!50] (3_2) {N};
        \node[TextBlock] (3_3) {N};
        %
        \node[on chain, xshift=2em] (1_info) {\texttt{i=2; j=2} $\implies$ Mismatch!};
        }

        { [continue chain = going right]
        \chainin (03);
        \node[TextBlock, xshift=-2em, yshift=-8em, fill=red!50] (1_0) {S};
        \node[TextBlock] (4_1) {I};
        \node[TextBlock] (4_2) {N};
        \node[TextBlock] (4_3) {N};
        %
        \node[on chain, xshift=2em] (1_info) {\texttt{i=3; j=0} $\implies$ Mismatch!};
        }

        { [continue chain = going right]
        \chainin (04);
        \node[TextBlock, xshift=-2em, yshift=-10em, fill=teal!50] (1_0) {S};
        \node[TextBlock, fill=red!50] (5_1) {I};
        \node[TextBlock] (5_2) {N};
        \node[TextBlock] (5_3) {N};
        %
        \node[on chain, xshift=2em] (1_info) {\texttt{i=4; j=1} $\implies$ Mismatch!};
        }

        { [continue chain = going right]
        \chainin (05);
        \node[TextBlock, xshift=-2em, yshift=-12em, fill=red!50] (1_0) {S};
        \node[TextBlock] (5_1) {I};
        \node[TextBlock] (5_2) {N};
        \node[TextBlock] (5_3) {N};
        %
        \node[on chain, xshift=2em] (1_info) {\texttt{i=5; j=0} $\implies$ Mismatch!};
        }

        { [continue chain = going right]
        \chainin (06);
        \node[TextBlock, xshift=-2em, yshift=-14em, fill=teal!50] (1_0) {S};
        \node[TextBlock, fill=teal!50] (5_1) {I};
        \node[TextBlock, fill=teal!50] (5_2) {N};
        \node[TextBlock, fill=teal!50] (5_3) {N};
        %
        \node[on chain, xshift=2em] (1_info) {\textcolor{teal}{\texttt{i=6; j=4} $\implies$ Match!}};
        }
        }
    \end{tikzpicture}
\end{example}

\begin{algo}{Knuth-Morris-Pratt-Algorithmus}
    Der \emph{Knuth-Morris-Pratt-Algorithmus} baut auf der naiven Textsuche auf.

    Der Unterschied liegt darin, dass bei einem Mismatch das Muster nicht nur um eine Position verschoben werden kann, sondern um mehrere gleichzeitig.
    Dabei gilt:
    \begin{itemize}
        \item \textbf{Fall 1:} Wenn die letzten überprüften Buchstaben gleich dem Anfang des Patterns sind, verschiebt man das Muster entsprechend und macht beim anschließenden Zeichen weiter.
        \item \textbf{Fall 2:} Wenn die letzten überprüften Buchstaben nicht gleich dem Anfang des Musters sind, verschiebt man das Muster so, dass das erste Zeichen auf dem Mismatch zu liegen kommt.
    \end{itemize}
\end{algo}

\begin{example}{Knuth-Morris-Pratt-Algorithmus}
    \textbf{Aufgabe:} Finde das Muster \texttt{UNGLEICHUNGEN} im Text \texttt{UNGLEICHUNGSTEIL...} mithilfe des Knuth-Morris-Pratt-Algorithmus.

    \vspace{1em}

    \begin{center}
        \begin{tikzpicture}[
            start chain,
            node distance = 0pt,
            TextBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
            \node [TextBlock] (00) {U};
            \node [TextBlock] (01) {N};
            \node [TextBlock] (02) {G};
            \node [TextBlock] (03) {L};
            \node [TextBlock] (04) {E};
            \node [TextBlock] (05) {I};
            \node [TextBlock] (06) {C};
            \node [TextBlock] (07) {H};
            \node [TextBlock] (08) {U};
            \node [TextBlock] (09) {N};
            \node [TextBlock] (10) {G};
            \node [TextBlock] (11) {S};
            \node [TextBlock] (12) {T};
            \node [TextBlock] (13) {E};
            \node [TextBlock] (14) {I};
            \node [TextBlock] (15) {L};
            \node [TextBlock] (16) {$\ldots$};

            { [continue chain = going right]
            \chainin (00);

            \node[TextBlock, xshift=-2em, yshift=2em, index] () {\tiny 0};
            \node [TextBlock, index] () {\tiny 1};
            \node [TextBlock, index] () {\tiny 2};
            \node [TextBlock, index] () {\tiny 3};
            \node [TextBlock, index] () {\tiny 4};
            \node [TextBlock, index] () {\tiny 5};
            \node [TextBlock, index] () {\tiny 6};
            \node [TextBlock, index] () {\tiny 7};
            \node [TextBlock, index] () {\tiny 8};
            \node [TextBlock, index] () {\tiny 9};
            \node [TextBlock, index] () {\tiny 10};
            \node [TextBlock, index] () {\tiny 11};
            \node [TextBlock, index] () {\tiny 12};
            \node [TextBlock, index] () {\tiny 13};
            \node [TextBlock, index] () {\tiny 14};
            \node [TextBlock, index] () {\tiny 15};
            \node [TextBlock, index] () {\tiny 16};
            }


            { [continue chain = going right]
            \chainin (00);
            \node[TextBlock, xshift=-2em, yshift=-2em, fill=teal!50] (1_00)  {U};
            \node [TextBlock, fill=teal!50] (1_01) {N};
            \node [TextBlock, fill=teal!50] (1_02) {G};
            \node [TextBlock, fill=teal!50] (1_03) {L};
            \node [TextBlock, fill=teal!50] (1_04) {E};
            \node [TextBlock, fill=teal!50] (1_05) {I};
            \node [TextBlock, fill=teal!50] (1_06) {C};
            \node [TextBlock, fill=teal!50] (1_07) {H};
            \node [TextBlock, fill=teal!50] (1_08) {U};
            \node [TextBlock, fill=teal!50] (1_09) {N};
            \node [TextBlock, fill=teal!50] (1_10) {G};
            \node [TextBlock, fill=red!50] (1_11) {E};
            \node [TextBlock] (1_12) {N};
            %
            \node[on chain, xshift=2em] (1_info) {$\implies$ Fall 1};
            }

            { [continue chain = going right]
            \chainin (08);
            \node[TextBlock, xshift=-2em, yshift=-4em, fill=teal!50] (2_00)  {U};
            \node [TextBlock, fill=teal!50] (2_01) {N};
            \node [TextBlock, fill=teal!50] (2_02) {G};
            \node [TextBlock, fill=red!50] (2_03) {L};
            \node [TextBlock] (2_04) {E};
            \node [TextBlock] (2_05) {I};
            \node [TextBlock] (2_06) {C};
            \node [TextBlock] (2_07) {H};
            \node [TextBlock] (2_08) {$\ldots$};
            }

            { [continue chain = going below]
            \chainin (2_00);
            \node [on chain, minimum width=2em, minimum height=2em] (usw) {usw.};
            }
            }
            \node [draw, dashed, fit={(00) (01) (02) (1_00) (1_01) (1_02)}] {};
            \node [draw, dashed, fit={(08) (09) (10) (1_08) (1_09) (1_10)}] {};
        \end{tikzpicture}
    \end{center}

    \textbf{Aufgabe:} Finde das Muster \texttt{UNGLEICHER} im Text \texttt{UNGLEICHUNGSTEIL...} mithilfe des Knuth-Morris-Pratt-Algorithmus.

    \vspace{1em}

    \begin{center}
        \begin{tikzpicture}[
            start chain,
            node distance = 0pt,
            TextBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
            ]
            { start chain = going right
            \node [TextBlock] (00) {U};
            \node [TextBlock] (01) {N};
            \node [TextBlock] (02) {G};
            \node [TextBlock] (03) {L};
            \node [TextBlock] (04) {E};
            \node [TextBlock] (05) {I};
            \node [TextBlock] (06) {C};
            \node [TextBlock] (07) {H};
            \node [TextBlock] (08) {U};
            \node [TextBlock] (09) {N};
            \node [TextBlock] (10) {G};
            \node [TextBlock] (11) {S};
            \node [TextBlock] (12) {T};
            \node [TextBlock] (13) {E};
            \node [TextBlock] (14) {I};
            \node [TextBlock] (15) {L};
            \node [TextBlock] (16) {$\ldots$};

            { [continue chain = going right]
            \chainin (00);

            \node[TextBlock, xshift=-2em, yshift=2em, index] () {\tiny 0};
            \node [TextBlock, index] () {\tiny 1};
            \node [TextBlock, index] () {\tiny 2};
            \node [TextBlock, index] () {\tiny 3};
            \node [TextBlock, index] () {\tiny 4};
            \node [TextBlock, index] () {\tiny 5};
            \node [TextBlock, index] () {\tiny 6};
            \node [TextBlock, index] () {\tiny 7};
            \node [TextBlock, index] () {\tiny 8};
            \node [TextBlock, index] () {\tiny 9};
            \node [TextBlock, index] () {\tiny 10};
            \node [TextBlock, index] () {\tiny 11};
            \node [TextBlock, index] () {\tiny 12};
            \node [TextBlock, index] () {\tiny 13};
            \node [TextBlock, index] () {\tiny 14};
            \node [TextBlock, index] () {\tiny 15};
            \node [TextBlock, index] () {\tiny 16};
            }

            { [continue chain = going right]
            \chainin (00);
            \node[TextBlock, xshift=-2em, yshift=-2em, fill=teal!50] (1_00)  {U};
            \node [TextBlock, fill=teal!50] (1_01) {N};
            \node [TextBlock, fill=teal!50] (1_02) {G};
            \node [TextBlock, fill=teal!50] (1_03) {L};
            \node [TextBlock, fill=teal!50] (1_04) {E};
            \node [TextBlock, fill=teal!50] (1_05) {I};
            \node [TextBlock, fill=teal!50] (1_06) {C};
            \node [TextBlock, fill=teal!50] (1_07) {H};
            \node [TextBlock, fill=red!50] (1_08) {E};
            \node [TextBlock] (1_09) {R};
            %
            \node[on chain, xshift=2em] (1_info) {$\implies$ Fall 2};
            }

            { [continue chain = going right]
            \chainin (08);
            \node[TextBlock, xshift=-2em, yshift=-4em, fill=teal!50] (2_00)  {U};
            \node [TextBlock, fill=teal!50] (2_01) {N};
            \node [TextBlock, fill=teal!50] (2_02) {G};
            \node [TextBlock, fill=red!50] (2_03) {L};
            \node [TextBlock] (2_04) {E};
            \node [TextBlock] (2_05) {I};
            \node [TextBlock] (2_06) {C};
            \node [TextBlock] (2_07) {H};
            \node [TextBlock] (2_08) {$\ldots$};
            }

            { [continue chain = going below]
            \chainin (2_00);
            \node [on chain, minimum width=2em, minimum height=2em] (usw) {usw.};
            }
            }
        \end{tikzpicture}
    \end{center}
\end{example}

\begin{algo}{Boyer-Moore-Sunday-Algorithmus}
    Beim \emph{Boyer-Moore-Sunday-Algorithmus} wird nach einem Mismatch das Zeichen betrachtet, das hinter dem Muster liegt.

    Dabei kann das Muster so weit nach vorne geschoben werden, bis ein Buchstabe des Musters mit diesem Buchstaben übereinstimmt.\footnote{Taucht der Buchstabe mehrfach im Wort auf, wird um die geringste Distanz nach vorne geschoben - also an den Buchstaben, der im Muster am weitesten hinten liegt.}

    Kommt der folgende Buchstabe im Muster nicht vor, wird das Muster über den Buchstaben hinweggeschoben, da alle Positionen vorher sowieso zwecklos sind.
\end{algo}

\begin{example}{Boyer-Moore-Sunday-Algorithmus}
    \textbf{Aufgabe:} Finde das Muster \texttt{ACBABCBA} im Text \texttt{AABBACCBACDACBABCBA} mithilfe des Boyer-Moore-Sunday-Algorithmus.

    \centering

    \vspace{1em}

    \begin{tikzpicture}[
        start chain,
        node distance = 0pt,
        TextBlock/.style={draw, minimum width=2em, minimum height=2em, outer sep=0pt, on chain},
        hit/.style={fill=teal!50},
        miss/.style={fill=red!50},
        next/.style={fill=blue!25},
        ]
        { start chain = going right
        %\node [TextBlock, fill=red!50, label=$0$] (0) {};
        \node [TextBlock] (00) {A};
        \node [TextBlock] (01) {A};
        \node [TextBlock] (02) {B};
        \node [TextBlock] (03) {B};
        \node [TextBlock] (04) {A};
        \node [TextBlock] (05) {C};
        \node [TextBlock] (06) {C};
        \node [TextBlock] (07) {B};
        \node [TextBlock] (08) {A};
        \node [TextBlock] (09) {C};
        \node [TextBlock] (10) {D};
        \node [TextBlock] (11) {A};
        \node [TextBlock] (12) {C};
        \node [TextBlock] (13) {B};
        \node [TextBlock] (14) {A};
        \node [TextBlock] (15) {B};
        \node [TextBlock] (16) {C};
        \node [TextBlock] (17) {B};
        \node [TextBlock] (18) {A};

        { [continue chain = going right]
        \chainin (00);

        \node[TextBlock, xshift=-2em, yshift=2em, index] () {\tiny 0};
        \node [TextBlock, index] () {\tiny 1};
        \node [TextBlock, index] () {\tiny 2};
        \node [TextBlock, index] () {\tiny 3};
        \node [TextBlock, index] () {\tiny 4};
        \node [TextBlock, index] () {\tiny 5};
        \node [TextBlock, index] () {\tiny 6};
        \node [TextBlock, index] () {\tiny 7};
        \node [TextBlock, index] () {\tiny 8};
        \node [TextBlock, index] () {\tiny 9};
        \node [TextBlock, index] () {\tiny 10};
        \node [TextBlock, index] () {\tiny 11};
        \node [TextBlock, index] () {\tiny 12};
        \node [TextBlock, index] () {\tiny 13};
        \node [TextBlock, index] () {\tiny 14};
        \node [TextBlock, index] () {\tiny 15};
        \node [TextBlock, index] () {\tiny 16};
        \node [TextBlock, index] () {\tiny 17};
        \node [TextBlock, index] () {\tiny 18};
        }

        { [continue chain = going right]
        \chainin (00);

        \node[TextBlock, xshift=-2em, yshift=-2em, hit] (1_00) {A};
        \node [TextBlock, miss] (1_01) {C};
        \node [TextBlock] (1_02) {B};
        \node [TextBlock] (1_03) {A};
        \node [TextBlock] (1_04) {B};
        \node [TextBlock] (1_05) {C};
        \node [TextBlock] (1_06) {B};
        \node [TextBlock] (1_07) {A};
        }

        { [continue chain = going right]
        \chainin (01);

        \node[TextBlock, xshift=-2em, yshift=-4em, hit] (2_00) {A};
        \node [TextBlock, miss] (2_01) {C};
        \node [TextBlock] (2_02) {B};
        \node [TextBlock] (2_03) {A};
        \node [TextBlock] (2_04) {B};
        \node [TextBlock] (2_05) {C};
        \node [TextBlock] (2_06) {B};
        \node [TextBlock, next] (2_07) {A};
        }

        { [continue chain = going right]
        \chainin (04);

        \node[TextBlock, xshift=-2em, yshift=-6em, hit] (3_00) {A};
        \node [TextBlock, hit] (3_01) {C};
        \node [TextBlock, miss] (3_02) {B};
        \node [TextBlock] (3_03) {A};
        \node [TextBlock] (3_04) {B};
        \node [TextBlock, next] (3_05) {C};
        \node [TextBlock] (3_06) {B};
        \node [TextBlock] (3_07) {A};
        }

        { [continue chain = going right]
        \chainin (07);

        \node[TextBlock, xshift=-2em, yshift=-8em, miss] (4_00) {A};
        \node [TextBlock] (4_01) {C};
        \node [TextBlock] (4_02) {B};
        \node [TextBlock] (4_03) {A};
        \node [TextBlock] (4_04) {B};
        \node [TextBlock, next] (4_05) {C};
        \node [TextBlock] (4_06) {B};
        \node [TextBlock] (4_07) {A};
        }

        { [continue chain = going right]
        \chainin (09);

        \node[TextBlock, xshift=-2em, yshift=-10em, miss] (5_00) {A};
        \node [TextBlock] (5_01) {C};
        \node [TextBlock] (5_02) {B};
        \node [TextBlock] (5_03) {A};
        \node [TextBlock] (5_04) {B};
        \node [TextBlock] (5_05) {C};
        \node [TextBlock, next] (5_06) {B};
        \node [TextBlock] (5_07) {A};
        }

        { [continue chain = going right]
        \chainin (11);

        \node[TextBlock, xshift=-2em, yshift=-12em, hit] (6_00) {A};
        \node [TextBlock, hit] (6_01) {C};
        \node [TextBlock, hit] (6_02) {B};
        \node [TextBlock, hit] (6_03) {A};
        \node [TextBlock, hit] (6_04) {B};
        \node [TextBlock, hit] (6_05) {C};
        \node [TextBlock, next] (6_06) {B};
        \node [TextBlock, hit] (6_07) {A};
        }
        }
        \draw[->] (08) to (2_07);
        \draw[->] (09) to (3_05);
        \draw[->] (12) to (4_05);
        \draw[->] (15) to (5_06);
        \draw[->] (17) to (6_06);
    \end{tikzpicture}
\end{example}

\begin{defi}{\texttt{last}-Tabelle}
    Die \texttt{last}\emph{-Tabelle} enthält zu jedem Zeichen des Zeichensatzes die Position des letzten Vorkommens im Muster (oder $-1$, falls es nicht vorkommt).

    Die Implementierung erfolgt z.B. als Array indiziert mit (Unicode-)Zeichensatz:
    \begin{itemize}
        \item \texttt{A} auf Index $65$
        \item \texttt{B} auf Index $66$
        \item $\ldots$
        \item \texttt{a} auf Index $97$
        \item \texttt{b} auf Index $98$
        \item $\ldots$
    \end{itemize}

    Dabei gilt:
    \begin{itemize}
        \item Alte Position des Patterns: \texttt{i} (das Pattern reicht bis \texttt{i + m - 1})
        \item Verschiebedistanz: \texttt{v = m - last[text[i+m]]}
        \item Neue Position des Patterns: \texttt{i + v} (das Pattern reicht bis \texttt{i + v +  m - 1})
    \end{itemize}
\end{defi}

\begin{example}{Boyer-Moore-Sunday-Algorithmus mit \texttt{last}-Tabelle}
    \textbf{Aufgabe:} Finde das Muster \texttt{BANANAS} im Text \texttt{ORANGES, ANANANAS AND BANANANAS} mithilfe des Boyer-Moore-Sunday-Algorithmus und einer \texttt{last}-Tabelle.

    \centering

    \vspace{1em}

    \begin{tabular}{|l||cccc|c|}
        \hline
        Pattern            & B & A & N & S & sonst \\
        \hline
        \texttt{last}-Wert & 0 & 5 & 4 & 6 & -1    \\
        \hline
    \end{tabular}

    \vspace{1em}

    \begin{tikzpicture}[
        start chain,
        node distance = 0pt,
        TextBlock/.style={draw, minimum width=1.5em, minimum height=1.5em, outer sep=0pt, on chain},
        hit/.style={fill=teal!50},
        miss/.style={fill=red!50},
        next/.style={fill=blue!25},
        ]
        { start chain = going right
        %\node [TextBlock, fill=red!50, label=$0$] (0) {};
        \node [TextBlock] (00) {O};
        \node [TextBlock] (01) {R};
        \node [TextBlock] (02) {A};
        \node [TextBlock] (03) {N};
        \node [TextBlock] (04) {G};
        \node [TextBlock] (05) {E};
        \node [TextBlock] (06) {S};
        \node [TextBlock] (07) {,};
        \node [TextBlock] (08) {};
        \node [TextBlock] (09) {A};
        \node [TextBlock] (10) {N};
        \node [TextBlock] (11) {A};
        \node [TextBlock] (12) {N};
        \node [TextBlock] (13) {A};
        \node [TextBlock] (14) {S};
        \node [TextBlock] (15) {};
        \node [TextBlock] (16) {A};
        \node [TextBlock] (17) {N};
        \node [TextBlock] (18) {D};
        \node [TextBlock] (19) {};
        \node [TextBlock] (20) {B};
        \node [TextBlock] (21) {A};
        \node [TextBlock] (22) {N};
        \node [TextBlock] (23) {A};
        \node [TextBlock] (24) {N};
        \node [TextBlock] (25) {A};
        \node [TextBlock] (26) {S};

        { [continue chain = going right]
        \chainin (00);

        \node[TextBlock, xshift=-1.5em, yshift=1.5em, index small] () {\tiny 0};
        \node [TextBlock, index small] () {\tiny 1};
        \node [TextBlock, index small] () {\tiny 2};
        \node [TextBlock, index small] () {\tiny 3};
        \node [TextBlock, index small] () {\tiny 4};
        \node [TextBlock, index small] () {\tiny 5};
        \node [TextBlock, index small] () {\tiny 6};
        \node [TextBlock, index small] () {\tiny 7};
        \node [TextBlock, index small] () {\tiny 8};
        \node [TextBlock, index small] () {\tiny 9};
        \node [TextBlock, index small] () {\tiny 10};
        \node [TextBlock, index small] () {\tiny 11};
        \node [TextBlock, index small] () {\tiny 12};
        \node [TextBlock, index small] () {\tiny 13};
        \node [TextBlock, index small] () {\tiny 14};
        \node [TextBlock, index small] () {\tiny 15};
        \node [TextBlock, index small] () {\tiny 16};
        \node [TextBlock, index small] () {\tiny 17};
        \node [TextBlock, index small] () {\tiny 18};
        \node [TextBlock, index small] () {\tiny 19};
        \node [TextBlock, index small] () {\tiny 20};
        \node [TextBlock, index small] () {\tiny 21};
        \node [TextBlock, index small] () {\tiny 22};
        \node [TextBlock, index small] () {\tiny 23};
        \node [TextBlock, index small] () {\tiny 24};
        \node [TextBlock, index small] () {\tiny 25};
        \node [TextBlock, index small] () {\tiny 26};
        }

        { [continue chain = going right]
        \chainin (00);

        \node[TextBlock, xshift=-1.5em, yshift=-1.5em, miss] (1_00) {B};
        \node [TextBlock] (1_01) {A};
        \node [TextBlock] (1_02) {N};
        \node [TextBlock] (1_03) {A};
        \node [TextBlock] (1_04) {N};
        \node [TextBlock] (1_05) {A};
        \node [TextBlock] (1_06) {S};
        }

        { [continue chain = going right]
        \chainin (08);

        \node [TextBlock, xshift=-3em, yshift=-3em, dashed, blue] (2_left) {};
        \node [TextBlock, miss] (2_00) {B};
        \node [TextBlock] (2_01) {A};
        \node [TextBlock] (2_02) {N};
        \node [TextBlock] (2_03) {A};
        \node [TextBlock] (2_04) {N};
        \node [TextBlock] (2_05) {A};
        \node [TextBlock] (2_06) {S};
        }

        { [continue chain = going right]
        \chainin (16);

        \node [TextBlock, xshift=-3em, yshift=-4.5em, dashed, blue] (3_left) {};
        \node [TextBlock, miss] (3_00) {B};
        \node [TextBlock] (3_01) {A};
        \node [TextBlock] (3_02) {N};
        \node [TextBlock] (3_03) {A};
        \node [TextBlock] (3_04) {N};
        \node [TextBlock] (3_05) {A};
        \node [TextBlock] (3_06) {S};
        }

        { [continue chain = going right]
        \chainin (18);

        \node [TextBlock, xshift=-1.5em, yshift=-6em, miss] (4_00) {B};
        \node [TextBlock] (4_01) {A};
        \node [TextBlock] (4_02) {N};
        \node [TextBlock] (4_03) {A};
        \node [TextBlock] (4_04) {N};
        \node [TextBlock, next] (4_05) {A};
        \node [TextBlock] (4_06) {S};
        }

        { [continue chain = going right]
        \chainin (20);

        \node [TextBlock, xshift=-1.5em, yshift=-7.5em, hit] (5_00) {B};
        \node [TextBlock, hit] (5_01) {A};
        \node [TextBlock, hit] (5_02) {N};
        \node [TextBlock, hit] (5_03) {A};
        \node [TextBlock, hit] (5_04) {N};
        \node [TextBlock, next] (5_05) {A};
        \node [TextBlock, hit] (5_06) {S};
        }
        }
        \draw[->] (07) to node [midway, right] () {\small \color{blue} \texttt{v = 8}} (2_left);
        \draw[->] (15) to node [midway, right] () {\small \color{blue} \texttt{v = 8}} (3_left);
        \draw[->] (23) to node [midway, right] () {\small \color{blue} \texttt{v = 2}} (4_05);
        \draw[->] (25) to node [midway, right] () {\small \color{blue} \texttt{v = 2}} (5_05);
    \end{tikzpicture}
\end{example}

\begin{algo}{Rabin-Karp-Algorithmus}
    Der \emph{Rabin-Karp-Algorithmus} funktioniert sehr ähnlich zur naiver Textsuche.
    Im Gegensatz wird hier aber der Hashwert des jeweiligen Textfensters mit dem Hashwert des Musters verglichen.

    Nur wenn beide Hashwerte gleich sind, werden die beiden zeichenweise verglichen.

    Sind die Hashwerte verschieden, rückt das Textfenster einen Schritt weiter nach rechts.
\end{algo}

\begin{example}{Rabin-Karp-Algorithmus}
    \textbf{Aufgabe:} Finde das Muster \texttt{ANE} im Text \texttt{BENANE} mithilfe des Rabin-Karp-Algorithmus.

    Die Hashfunktion $h(x)$ sei gegeben durch die jeweile Position des Buchstaben $x$ im Alphabet.

    \vspace{1em}

    \centering

    \begin{tabular}{|c|cccccc|c|c|c|}
        \hline
        \rowcolor{gray!25} \texttt{i} & \multicolumn{6}{c|}{Textfenster} & Hashwerte  & Überprüfung? & Ergebnis                                                                                                         \\
        \hline
        \multirow{2}{*}{0}            & \textbf{B}                       & \textbf{E} & \textbf{N}   & A          & N          & E          & $h(BEN) = 21$ & \multirow{2}{*}{$\lightning$} & \multirow{2}{*}{}         \\
                                      & \textbf{A}                       & \textbf{N} & \textbf{E}   &            &            &            & $h(ANE) = 20$ &                               &                           \\
        \hline
        \multirow{2}{*}{1}            & B                                & \textbf{E} & \textbf{N}   & \textbf{A} & N          & E          & $h(ENA) = 20$ & \multirow{2}{*}{$\checkmark$} & \multirow{2}{*}{Mismatch} \\
                                      &                                  & \textbf{A} & \textbf{N}   & \textbf{E} &            &            & $h(ANE) = 20$ &                               &                           \\
        \hline
        \multirow{2}{*}{2}            & B                                & E          & \textbf{N}   & \textbf{A} & \textbf{N} & E          & $h(NAN) = 29$ & \multirow{2}{*}{$\lightning$} & \multirow{2}{*}{}         \\
                                      &                                  &            & \textbf{A}   & \textbf{N} & \textbf{E} &            & $h(ANE) = 20$ &                               &                           \\
        \hline
        \multirow{2}{*}{3}            & B                                & E          & N            & \textbf{A} & \textbf{N} & \textbf{E} & $h(ANE) = 20$ & \multirow{2}{*}{$\checkmark$} & \multirow{2}{*}{Match}    \\
                                      &                                  &            &              & \textbf{A} & \textbf{N} & \textbf{E} & $h(ANE) = 20$ &                               &                           \\
        \hline
    \end{tabular}
\end{example}

% Reguläre Ausdrücke

\subsection{Reguläre Ausdrücke}

\begin{bonus}{Regulärer Ausdruck (Begriffe)}
    \begin{itemize}
        \item Zeichen
              \begin{itemize}
                  \item z.B. Buchstabe, Ziffer
              \end{itemize}
        \item Alphabet
              \begin{itemize}
                  \item endliche Menge von Zeichen
                  \item z.B. $\Sigma = \{a, b, c\}$
              \end{itemize}
        \item Wort über Alphabet $\Sigma$
              \begin{itemize}
                  \item endliche Folge von Zeichen aus $\Sigma$
                  \item z.B. $abcb$
                  \item Spezialfall: leeres Wort $\varepsilon$
              \end{itemize}
        \item $\Sigma^*$
              \begin{itemize}
                  \item Menge aller Wörter über $\Sigma^*$
                  \item z.B. $\Sigma = \{a, b\} \implies \Sigma^* = \{\varepsilon, a, b, aa, ab, ba, bb, aaa, \ldots\}$
              \end{itemize}
        \item Sprache $L$ über Alphabet $\Sigma$
              \begin{itemize}
                  \item Teilmenge $L \subseteq \Sigma^*$
              \end{itemize}
    \end{itemize}
\end{bonus}

\begin{defi}{Regulärer Ausdruck}
    Ein \emph{regulärer Ausdruck} ist eine Formel, die eine Sprache beschreibt, d.h. eine Teilmenge aller möglichen Worte definiert.
\end{defi}

\begin{defi}{Verkettung}
    Bei der \emph{Verkettung} (Concatenation) werden zwei oder mehrere Buchstaben durch diese Operation aneinandergehängt, z.B. $ab$.

    Der Operator wird nicht mitgeschrieben.
\end{defi}

\begin{defi}{Alternative}
    Die \emph{Alternative} erlaubt die Angabe alternativer Zeichen im Muster.

    Schreibweise:
    \begin{itemize}
        \item $L((A \mid B)(A \mid B)) = \{AA, AB, BA, BB\}$
        \item $L((A \mid C)((B \mid C)D)) = \{ABD, CBD, ACD, CCD\}$
        \item $L(C(AC\mid B)D) = \{CACD, CBD\}$
    \end{itemize}
\end{defi}

\begin{defi}{Hüllenbildung}
    Die \emph{Hüllenbildung} (Closure) erlaubt es, Teile des Musters beliebig oft zu wiederholen.

    Schreibweise: Hinter den zu wiederholenden Buchstaben wird ein Stern $^*$ gesetzt.
    Sind mehrere Buchstaben zu wiederholen, müssen sie in Klammern gesetzt werden.
    \begin{itemize}
        \item $L(A^*) = \{\varepsilon, A, AA, AAA, \ldots\}$
        \item $L((ABC)^*) = \{\varepsilon, ABC, ABCABC, ABCABCABC, \ldots\}$
        \item $L(DA^*B) = \{DB, DAB, DAAB, DAAAB, \ldots\}$
    \end{itemize}
\end{defi}

\begin{defi}{Perl Compatible Regular Expressions}
    \emph{Perl Compatible Regular Expressions} (PCRE) ist eine Bibliothek zur Auswertung und Anwendung von regulären Ausdrücken.

    Sie beinhaltet standardisierte Regeln zur Erzeugung regulärer Ausdrückt für die Textsuche.

    Wichtige Regeln in PCRE sind:

    \centering

    \begin{tabular}{|>{\ttfamily}c|l|}
        \hline
        \rowcolor{gray!25} \multicolumn{2}{|c|}{Verknüpfungen}                                      \\
        \hline
        AB                               & Zeichenfolge $AB$                                        \\
        A|B                              & $A$ oder $B$                                             \\
        {[}AB{]}                         & Zeichenklasse $A$ oder $B$                               \\
        \hline
        \rowcolor{gray!25} \multicolumn{2}{|c|}{Quantoren}                                          \\
        \hline
        A\{n\}                           & $A$ kommt genau $n$-mal vor                              \\
        A\{min,\}                        & $A$ kommt mindestent $\min$-mal vor                      \\
        A\{min,max\}                     & $A$ kommt mindestens $\min$ und höchstens $\max$-mal vor \\
        \hline
        \rowcolor{gray!25} \multicolumn{2}{|c|}{Abkürzungen für Quantoren}                          \\
        \hline
        A?                               & entspricht \texttt{A\{0,1\}}                             \\
        A*                               & entspricht \texttt{A\{0,\}}                              \\
        A+                               & entspricht \texttt{A\{1,\}}                              \\
        A                                & entspricht \texttt{A\{1\}}                               \\
        \hline
        \rowcolor{gray!25} \multicolumn{2}{|c|}{Zeichenklassen}                                     \\
        \hline
        \textbackslash w                 & Buchstaben (word)                                        \\
        \textbackslash d                 & Zahlen (digit)                                           \\
        .                                & Alles außer Zeilenvorschub                               \\
        \hline
        \rowcolor{gray!25} \multicolumn{2}{|c|}{Referenzen}                                         \\
        \hline
        ()                               & Gruppierung                                              \\
        \textbackslash x \text{oder} \$x & $x$-te Rückwärtsreferenz                                 \\
        \hline
        \rowcolor{gray!25} \multicolumn{2}{|c|}{Greedy}                                             \\
        \hline
        (default)                        & Greedy                                                   \\
        ?                                & Reluctant, non-greedy                                    \\
        \hline
    \end{tabular}
\end{defi}

\begin{defi}{Endlicher Automat}
    Ein \emph{endlicher Automat} ist ein abstraktes Maschinenmodell.

    Seine Aufgabe ist zu entscheiden, ob ein Wort zu einer Sprache gehört, die durch einen regulären Ausdruck beschrieben ist (Akzeptoren).

    Am Anfang ist der Automat im \emph{Anfangszustand}.

    In jedem Schritt wird eine \emph{Eingabesymbol} $\sigma$ gelesen und abhängig von $\sigma$ geht die Maschine von einem \emph{Zustand} in einen bestimmten anderen über.

    Wenn nach Leses des letzten Zeichens ein \emph{Endzustand} erreicht ist, ist das Muster \emph{erkannt} und gehört damit zur Sprache.
\end{defi}

\begin{defi}{Konstruktionsverfahren nach Kleene}
    Das \emph{Konstruktionsverfahren nach Kleene} erzeugt aus einer gegeben regulären Sprache einen \emph{nichtdeterministischen endlichen Automaten} (NEA).\footnote{Es existiert zu jedem NEA ein DEA.}

    Die Grundlage ist das Zustands-Übergangs-Diagramm mit folgenden Elementen:

    \begin{center}
        \begin{tikzpicture}[node distance=4em, auto, label distance=1em]
            \node[initial,state,label=right:Anfangszustand] (start) {};
            \node[state,label=right:(Zwischen-)Zustand] (middle) [below of=start] {};
            \node[state,accepting,label=right:Endzustand] (end) [below of=middle] {};

            \node[state, draw=none,label=right:{Zustandsübergang bei einem gegebenen Symbol}] (transition_right) [below of=end] {};
            \node[state, draw=none] (transition_left) [left of=transition_right] {};

            \node[state, draw=none,label=right:{$\varepsilon$-Übergang}] (eps_right) [below of=transition_right] {};
            \node[state, draw=none] (eps_left) [left of=eps_right] {};

            \path[->]
            (transition_left) edge node {$a$} (transition_right)
            (eps_left) edge node {$\varepsilon$} (eps_right) ;
        \end{tikzpicture}
    \end{center}
\end{defi}

\begin{algo}{Konstruktion eines Automaten nach Kleene}
    Einzelnes Symbol: Regulärer Ausdruck \texttt{a}

    \begin{center}
        \begin{tikzpicture}[node distance=4em, auto]
            \node[initial, state] (start) {};
            \node[state, accepting] (end) [right of=start] {};

            \path[->]
            (start) edge node {$a$} (end) ;
        \end{tikzpicture}
    \end{center}

    Verkettung: Regulärer Ausdruck \texttt{ab}

    \begin{center}
        \begin{tikzpicture}[node distance=4em, auto]
            \node[initial, state] (start) {};
            \node[state] (q1) [right of=start] {};
            \node[state, accepting] (end) [right of=q1] {};

            \path[->]
            (start) edge node {$a$} (q1)
            (q1) edge node {$b$} (end) ;
        \end{tikzpicture}
    \end{center}

    Alternative: Regulärer Ausdruck \texttt{a|b}

    \begin{center}
        \begin{tikzpicture}[node distance=4em, auto]
            \node[initial, state] (start) {};
            \node[state] (q1) [above right of=start] {};
            \node[state] (q2) [below right of=start] {};
            \node[state] (q3) [right of=q1] {};
            \node[state] (q4) [right of=q2] {};
            \node[state, accepting] (end) [below right of=q3] {};

            \path[->]
            (start) edge node {$\varepsilon$} (q1)
            (start) edge node {$\varepsilon$} (q2)
            (q1) edge node {$a$} (q3)
            (q2) edge node {$b$} (q4)
            (q3) edge node {$\varepsilon$} (end)
            (q4) edge node {$\varepsilon$} (end) ;
        \end{tikzpicture}
    \end{center}

    Hüllenbildung: Regulärer Ausdruck \texttt{a*}

    \begin{center}
        \begin{tikzpicture}[node distance=4em, auto]
            \node[initial, state] (start) {};
            \node[state] (q1) [right of=start] {};
            \node[state] (q2) [right of=q1] {};
            \node[state, accepting] (end) [right of=q2] {};

            \path[->]
            (start) edge node {$\varepsilon$} (q1)
            (q1) edge node {$a$} (q2)
            (q2) edge [bend right=90] node[above] {$\varepsilon$} (q1)
            (q2) edge node {$\varepsilon$} (end)
            (start) edge [bend right=45] node {$\varepsilon$} (end) ;
        \end{tikzpicture}
    \end{center}
\end{algo}

\begin{example}{Konstruktion eines Automaten nach Kleene}
    Aufbau des Automaten für den regulären Ausdruck \texttt{a|a(a|b)*a}

    1. Schritt: \texttt{\textcolor{red}{a|b}}

    \begin{center}
        \begin{tikzpicture}[node distance=4em, auto, red]
            \node[state] (start) {};
            \node[state] (q1) [above right of=start] {};
            \node[state] (q2) [below right of=start] {};
            \node[state] (q3) [right of=q1] {};
            \node[state] (q4) [right of=q2] {};
            \node[state, accepting] (end) [below right of=q3] {};

            \path[->]
            (start) edge node {$\varepsilon$} (q1)
            (start) edge node {$\varepsilon$} (q2)
            (q1) edge node {$a$} (q3)
            (q2) edge node {$b$} (q4)
            (q3) edge node {$\varepsilon$} (end)
            (q4) edge node {$\varepsilon$} (end) ;
        \end{tikzpicture}
    \end{center}

    2. Schritt: \texttt{\textcolor{red}{(}a|b\textcolor{red}{)*}}

    \begin{center}
        \begin{tikzpicture}[node distance=2em,auto]

            \node[state, new] (q3) {};
            \node[state] (q4) [right=of q3] {};
            \node[state] (q5) [above right=of q4] {};
            \node[state] (q6) [below right=of q4] {};
            \node[state] (q7) [right=of q5] {};
            \node[state] (q8) [right=of q6] {};
            \node[state] (q9) [below right=of q7] {};
            \node[state, new] (q10) [right=of q9] {};

            \path[->]
            (q3) edge [new] node [new] {$\varepsilon$} (q4)
            (q4) edge node {$\varepsilon$} (q5)
            (q4) edge node {$\varepsilon$} (q6)
            (q5) edge node {$a$} (q7)
            (q6) edge node {$b$} (q8)
            (q7) edge node {$\varepsilon$} (q9)
            (q8) edge node {$\varepsilon$} (q9)
            (q9) edge [new] node [new] {$\varepsilon$} (q10)

            (q9) edge [new, bend left=90,min distance=6em] node [new, above] {$\varepsilon$} (q4)
            (q3) edge [new, bend right=90,min distance=8em] node [new] {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}

    3. Schritt: \texttt{\textcolor{red}{a}(a|b)*\textcolor{red}{a}}

    \begin{center}
        \begin{tikzpicture}[node distance=2em, auto]
            \node[state, new] (q2) [below right=of start] {};

            \node[state] (q3) [right=of q2] {};
            \node[state] (q4) [right=of q3] {};
            \node[state] (q5) [above right=of q4] {};
            \node[state] (q6) [below right=of q4] {};
            \node[state] (q7) [right=of q5] {};
            \node[state] (q8) [right=of q6] {};
            \node[state] (q9) [below right=of q7] {};
            \node[state] (q10) [right=of q9] {};
            \node[state, new] (q11) [right=of q10] {};

            \path[->]
            (q2) edge [new] node [new] {$a$} (q3)
            (q3) edge node {$\varepsilon$} (q4)
            (q4) edge node {$\varepsilon$} (q5)
            (q4) edge node {$\varepsilon$} (q6)
            (q5) edge node {$a$} (q7)
            (q6) edge node {$b$} (q8)
            (q7) edge node {$\varepsilon$} (q9)
            (q8) edge node {$\varepsilon$} (q9)
            (q9) edge node {$\varepsilon$} (q10)
            (q10) edge [new] node [new] {$a$} (q11)

            (q9) edge [bend left=90,min distance=6em] node [above] {$\varepsilon$} (q4)
            (q3) edge [bend right=90,min distance=8em] node {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}

    4. Schritt: \texttt{\textcolor{red}{a|}(a|b)*a}

    \begin{center}
        \begin{tikzpicture}[node distance=2em, auto, every initial by arrow/.style={red}]
            \node[initial, state, new] (start) {};
            \node[state, new] (q1) [above right=of start] {};
            \node[state] (q2) [below right=of start] {};

            \node[state] (q3) [right=of q2] {};
            \node[state] (q4) [right=of q3] {};
            \node[state] (q5) [above right=of q4] {};
            \node[state] (q6) [below right=of q4] {};
            \node[state] (q7) [right=of q5] {};
            \node[state] (q8) [right=of q6] {};
            \node[state] (q9) [below right=of q7] {};
            \node[state] (q10) [right=of q9] {};
            \node[state] (q11) [right=of q10] {};
            \node[state, accepting, new] (end) [above right=of q11] {};
            \node[state, new] (q12) [above left=of end] {};

            \path[->]
            (start) edge [new] node [new] {$\varepsilon$} (q1)
            (start) edge [new] node [new] {$\varepsilon$} (q2)
            (q2) edge node {$a$} (q3)
            (q3) edge node {$\varepsilon$} (q4)
            (q4) edge node {$\varepsilon$} (q5)
            (q4) edge node {$\varepsilon$} (q6)
            (q5) edge node {$a$} (q7)
            (q6) edge node {$b$} (q8)
            (q7) edge node {$\varepsilon$} (q9)
            (q8) edge node {$\varepsilon$} (q9)
            (q9) edge node {$\varepsilon$} (q10)
            (q10) edge node {$a$} (q11)
            (q11) edge [new] node [new] {$\varepsilon$} (end)
            (q12) edge [new] node [new] {$\varepsilon$} (end)
            (q1) edge [new] node [new] {$a$} (q12)

            (q9) edge [bend left=90,min distance=6em] node [above] {$\varepsilon$} (q4)
            (q3) edge [bend right=90,min distance=8em] node {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}
\end{example}

\begin{algo}{Ablaufregeln der Simulation nach Kleene}
    \begin{enumerate}
        \item Initialisierung
              \begin{enumerate}
                  \item Markiere den Anfangszustand
                  \item Markiere alle Zustande, die durch $\varepsilon$-Übergänge erreichbar sind.
              \end{enumerate}
        \item Für jedes gelesene Eingabesymbol
              \begin{enumerate}
                  \item Markiere alle Zustände, die durch dieses Eingabeymbol erreichbar sind.
                  \item Lösche alle anderen Zustände.
                  \item Markiere alle Zustände, die jetzt durch $\varepsilon$-Übergänge erreichbar sind.
              \end{enumerate}
    \end{enumerate}
\end{algo}

\begin{example}{Ablauf der Simulation nach Kleene}
    \textbf{Aufgabe:} Prüfen Sie, ob das Wort \texttt{abba} von dem Automaten der regulären Sprache \texttt{a|a(a|b)*a} akzeptiert wird.

    Anfangszustand:

    \begin{center}
        \begin{tikzpicture}[node distance=2em, auto, every initial by arrow/.style={teal}]
            \node[initial, state, current] (start) {};
            \node[state, marked] (q1) [above right=of start] {};
            \node[state, marked] (q2) [below right=of start] {};

            \node[state] (q3) [right=of q2] {};
            \node[state] (q4) [right=of q3] {};
            \node[state] (q5) [above right=of q4] {};
            \node[state] (q6) [below right=of q4] {};
            \node[state] (q7) [right=of q5] {};
            \node[state] (q8) [right=of q6] {};
            \node[state] (q9) [below right=of q7] {};
            \node[state] (q10) [right=of q9] {};
            \node[state] (q11) [right=of q10] {};
            \node[state, accepting] (end) [above right=of q11] {};
            \node[state] (q12) [above left=of end] {};

            \path[->]
            (start) edge [teal] node [teal] {$\varepsilon$} (q1)
            (start) edge [teal] node [teal] {$\varepsilon$} (q2)
            (q2) edge node {$a$} (q3)
            (q3) edge node {$\varepsilon$} (q4)
            (q4) edge node {$\varepsilon$} (q5)
            (q4) edge node {$\varepsilon$} (q6)
            (q5) edge node {$a$} (q7)
            (q6) edge node {$b$} (q8)
            (q7) edge node {$\varepsilon$} (q9)
            (q8) edge node {$\varepsilon$} (q9)
            (q9) edge node {$\varepsilon$} (q10)
            (q10) edge node {$a$} (q11)
            (q11) edge node {$\varepsilon$} (end)
            (q12) edge node {$\varepsilon$} (end)
            (q1) edge node {$a$} (q12)

            (q9) edge [bend left=90,min distance=6em] node [above] {$\varepsilon$} (q4)
            (q3) edge [bend right=90,min distance=8em] node {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}

    1. Buchstabe: \texttt{a}

    \begin{center}
        \begin{tikzpicture}[node distance=2em, auto]
            \node[initial, state] (start) {};
            \node[state] (q1) [above right=of start] {};
            \node[state] (q2) [below right=of start] {};

            \node[state, current] (q3) [right=of q2] {};
            \node[state, marked] (q4) [right=of q3] {};
            \node[state, marked] (q5) [above right=of q4] {};
            \node[state, marked] (q6) [below right=of q4] {};
            \node[state] (q7) [right=of q5] {};
            \node[state] (q8) [right=of q6] {};
            \node[state] (q9) [below right=of q7] {};
            \node[state, marked] (q10) [right=of q9] {};
            \node[state] (q11) [right=of q10] {};
            \node[state, accepting, marked] (end) [above right=of q11] {};
            \node[state, current] (q12) [above left=of end] {};

            \path[->]
            (start) edge node {$\varepsilon$} (q1)
            (start) edge node {$\varepsilon$} (q2)
            (q2) edge [blue] node [blue] {$a$} (q3)
            (q3) edge [teal] node [teal] {$\varepsilon$} (q4)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q5)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q6)
            (q5) edge node {$a$} (q7)
            (q6) edge node {$b$} (q8)
            (q7) edge node {$\varepsilon$} (q9)
            (q8) edge node {$\varepsilon$} (q9)
            (q9) edge node {$\varepsilon$} (q10)
            (q10) edge node {$a$} (q11)
            (q11) edge node {$\varepsilon$} (end)
            (q12) edge node {$\varepsilon$} (end)
            (q1) edge [blue] node [blue] {$a$} (q12)

            (q9) edge [bend left=90,min distance=6em] node [above] {$\varepsilon$} (q4)
            (q3) edge [teal] [bend right=90,min distance=8em] node [teal] {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}
\end{example}

\begin{example}{Ablauf der Simulation nach Kleene (Fortsetzung)}

    2. Buchstabe: \texttt{b}

    \begin{center}
        \begin{tikzpicture}[node distance=2em, auto]
            \node[initial, state] (start) {};
            \node[state] (q1) [above right=of start] {};
            \node[state] (q2) [below right=of start] {};

            \node[state] (q3) [right=of q2] {};
            \node[state, marked] (q4) [right=of q3] {};
            \node[state, marked] (q5) [above right=of q4] {};
            \node[state, marked] (q6) [below right=of q4] {};
            \node[state] (q7) [right=of q5] {};
            \node[state, current] (q8) [right=of q6] {};
            \node[state, marked] (q9) [below right=of q7] {};
            \node[state, marked] (q10) [right=of q9] {};
            \node[state] (q11) [right=of q10] {};
            \node[state, accepting] (end) [above right=of q11] {};
            \node[state] (q12) [above left=of end] {};

            \path[->]
            (start) edge node {$\varepsilon$} (q1)
            (start) edge node {$\varepsilon$} (q2)
            (q2) edge node {$a$} (q3)
            (q3) edge node {$\varepsilon$} (q4)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q5)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q6)
            (q5) edge node {$a$} (q7)
            (q6) edge [blue] node [blue] {$b$} (q8)
            (q7) edge node {$\varepsilon$} (q9)
            (q8) edge [teal] node [teal] {$\varepsilon$} (q9)
            (q9) edge [teal] node [teal] {$\varepsilon$} (q10)
            (q10) edge node {$a$} (q11)
            (q11) edge node {$\varepsilon$} (end)
            (q12) edge node {$\varepsilon$} (end)
            (q1) edge node {$a$} (q12)

            (q9) edge [teal] [bend left=90,min distance=6em] node [teal] [above] {$\varepsilon$} (q4)
            (q3) edge [bend right=90,min distance=8em] node {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}

    3. Buchstabe: \texttt{b}

    \begin{center}
        \begin{tikzpicture}[node distance=2em, auto]
            \node[initial, state] (start) {};
            \node[state] (q1) [above right=of start] {};
            \node[state] (q2) [below right=of start] {};

            \node[state] (q3) [right=of q2] {};
            \node[state, marked] (q4) [right=of q3] {};
            \node[state, marked] (q5) [above right=of q4] {};
            \node[state, marked] (q6) [below right=of q4] {};
            \node[state] (q7) [right=of q5] {};
            \node[state, current] (q8) [right=of q6] {};
            \node[state, marked] (q9) [below right=of q7] {};
            \node[state, marked] (q10) [right=of q9] {};
            \node[state] (q11) [right=of q10] {};
            \node[state, accepting] (end) [above right=of q11] {};
            \node[state] (q12) [above left=of end] {};

            \path[->]
            (start) edge node {$\varepsilon$} (q1)
            (start) edge node {$\varepsilon$} (q2)
            (q2) edge node {$a$} (q3)
            (q3) edge node {$\varepsilon$} (q4)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q5)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q6)
            (q5) edge node {$a$} (q7)
            (q6) edge [blue] node [blue] {$b$} (q8)
            (q7) edge node {$\varepsilon$} (q9)
            (q8) edge [teal] node [teal] {$\varepsilon$} (q9)
            (q9) edge [teal] node [teal] {$\varepsilon$} (q10)
            (q10) edge node {$a$} (q11)
            (q11) edge node {$\varepsilon$} (end)
            (q12) edge node {$\varepsilon$} (end)
            (q1) edge node {$a$} (q12)

            (q9) edge [teal] [bend left=90,min distance=6em] node [teal] [above] {$\varepsilon$} (q4)
            (q3) edge [bend right=90,min distance=8em] node {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}

    4. Buchstabe: \texttt{a}

    \begin{center}
        \begin{tikzpicture}[node distance=2em, auto]
            \node[initial, state] (start) {};
            \node[state] (q1) [above right=of start] {};
            \node[state] (q2) [below right=of start] {};

            \node[state] (q3) [right=of q2] {};
            \node[state, marked] (q4) [right=of q3] {};
            \node[state, marked] (q5) [above right=of q4] {};
            \node[state, marked] (q6) [below right=of q4] {};
            \node[state, current] (q7) [right=of q5] {};
            \node[state] (q8) [right=of q6] {};
            \node[state, marked] (q9) [below right=of q7] {};
            \node[state, marked] (q10) [right=of q9] {};
            \node[state, current] (q11) [right=of q10] {};
            \node[state, accepting, marked] (end) [above right=of q11] {};
            \node[state] (q12) [above left=of end] {};

            \path[->]
            (start) edge node {$\varepsilon$} (q1)
            (start) edge node {$\varepsilon$} (q2)
            (q2) edge node {$a$} (q3)
            (q3) edge node {$\varepsilon$} (q4)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q5)
            (q4) edge [teal] node [teal] {$\varepsilon$} (q6)
            (q5) edge [blue] node [blue] {$a$} (q7)
            (q6) edge node {$b$} (q8)
            (q7) edge [teal] node [teal] {$\varepsilon$} (q9)
            (q8) edge node {$\varepsilon$} (q9)
            (q9) edge [teal] node [teal] {$\varepsilon$} (q10)
            (q10) edge [blue] node [blue] {$a$} (q11)
            (q11) edge [teal] node [teal] {$\varepsilon$} (end)
            (q12) edge node {$\varepsilon$} (end)
            (q1) edge node {$a$} (q12)

            (q9) edge [teal] [bend left=90,min distance=6em] node [teal] [above] {$\varepsilon$} (q4)
            (q3) edge [bend right=90,min distance=8em] node {$\varepsilon$} (q10)
            ;
        \end{tikzpicture}
    \end{center}

    Damit wird \texttt{abba} durch den regulären Ausdruck \texttt{a|a(a|b)*a} beschrieben.
\end{example}