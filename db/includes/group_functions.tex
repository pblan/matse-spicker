\section{Group Functions}

\begin{sql}{GROUP BY}
    \texttt{GROUP BY} teilt die Gesamtmenge in Teilmengen bzw. Gruppierungen auf.
    
    Auf diese Teilmengen können ausschließlich Methoden speziell für Datensätze, wie beispielsweise \texttt{COUNT}, aufgerufen.
    Attributwerte, welche sich innerhalb einer Teilmenge unterscheiden, können nicht direkt aufgerufen werden.\footnote{
        Da es in der Tabelle \texttt{attacke} Attacken mit dem selben \texttt{Namen} gibt, welche sich insbesondere durch ihre \texttt{Schadensklasse} unterscheiden, kann man, wenn man nach dem \texttt{Namen} gruppiert, die jeweilige \texttt{Schadensklasse} nicht aufrufen.
        Je nach DBMS ist es trotzdem möglich die gleichbleibenden Attribute \texttt{Name}, \texttt{Typ}, \texttt{Stärke}, \texttt{Genauigkeit}, \texttt{AP} und \texttt{Generation} zu verwenden.
    }

    Gibt man bei dem Keyword \texttt{GROUP BY} mehrere Attribute an, wird der Datensatz nach dem Tupel dieser gruppiert.
    Dabei wird zunächst nach dem ersten Attribut gruppiert, folgend innerhalb dieser Teilgruppen dem Zweiten, etc. 
\end{sql}

\begin{sql}{HAVING}
    \texttt{HAVING} filtert die mit \texttt{GROUP BY} gruppierten Teilmengen.
    
    Dabei werden Bedingungen auf das Ergebnis der Abfrage angewandt.

    Gibt man sich beispielsweise alle Typen aus, welche mindestens von 25 Attacken genutzt werden, so erhält man:
    
    \begin{lstlisting}[style=SqlInputStyle]
        SELECT
            Typ,
            COUNT(*) AS Anzahl
        FROM attacke
        GROUP BY Typ
        HAVING Anzahl >= 25
        ORDER BY Anzahl DESC;
    \end{lstlisting}

    \begin{tabular}{I|TI}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Typ} & \multicolumn{1}{T}{Anzahl} \\\hline
        1 & Normal & 188 \\
        2 & Psycho & 69 \\
        3 & Pflanze & 52 \\
        \multicolumn{1}{c|}{\dots} & \multicolumn{2}{c}{\dots} \\
        17 & Drache & 27 \\
    \end{tabular}
\end{sql}

\subsection{Funktionen}

\begin{sql}{MIN, MAX}
    \texttt{MIN} gibt den alphanumerisch ersten Eintrag eines Datensatzes zurück.

    \texttt{MAX} hingegen gibt den alphanumerisch letzten Eintrag eines Datensatzes zurück.
\end{sql}

\begin{sql}{AVG}
    \texttt{AVG} gibt den durchschnittlichen Zahlwert eines Datensatzes zurück.
\end{sql}

\begin{sql}{SUM}
    \texttt{SUM} gibt die Summe alles Zahlenwerte eines Datensatzes zurück
\end{sql}

\subsection{Beispiele}

\begin{example}{GROUP BY}
    \begin{lstlisting}[style=SqlInputStyle]
        SELECT
            typ,
            MIN(Staerke),
            MAX(Staerke),
            SUM(Staerke),
            AVG(Staerke)
        FROM attacke
        GROUP BY typ;
    \end{lstlisting}

    \begin{tabular}{I|TIIIII}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{typ} & \multicolumn{1}{T}{COUNT(*)} & \multicolumn{1}{T}{MIN(Staerke)} & \multicolumn{1}{T}{MAX(Staerke)} & \multicolumn{1}{T}{SUM(Staerke)} & \multicolumn{1}{T}{AVG(Staerke)} \\\hline
        1 & Boden & 29 & 10 & 120 & 1365 & 68.2500 \\
        2 & Drache & 27 & 10 & 185 & 2005 & 91.1364 \\
        3 & Eis & 29 & 10 & 140 & 1575 & 71.5909 \\
        4 & Elektro & 43 & 10 & 210 & 2740 & 88.3871 \\
        5 & Fee & 30 & 10 & 190 & 1250 & 89.2857 \\
        6 & Feuer & 40 & 35 & 180 & 3370 & 96.2857 \\
        7 & Flug & 30 & 10 & 140 & 1735 & 75.4348 \\
        8 & Geist & 30 & 10 & 200 & 1815 & 90.7500 \\
        9 & Gestein & 23 & 10 & 190 & 1290 & 80.6250 \\
        10 & Gift & 31 & 10 & 120 & 1080 & 63.5294 \\
        11 & Käfer & 32 & 10 & 120 & 1340 & 63.8095 \\
        12 & Kampf & 51 & 10 & 150 & 2810 & 75.9459 \\
        13 & Normal & 188 & 10 & 250 & 5441 & 72.5467 \\
        14 & Pflanze & 52 & 10 & 150 & 2560 & 77.5758 \\
        15 & Psycho & 69 & 10 & 200 & 2385 & 91.7308 \\
        16 & Stahl & 32 & 10 & 200 & 1815 & 86.4286 \\
        17 & Unlicht & 47 & 10 & 180 & 1950 & 72.2222 \\
        18 & Wasser & 42 & 10 & 195 & 2635 & 77.5000 \\
    \end{tabular}
    %\setcounter{rownum}{0}
\end{example}

\begin{example}{GROUP BY}
    Geben Sie alle Attacken aus mit einer echter Stärke (>0) geordnet aus.
    Gruppieren Sie diese nach Typ und ermitteln Sie die \texttt{MIN} und \texttt{MAX} Stärke.
    Ergänzen Sie diese um die Durchschnittsstärke und geben Sie nur die Einträge aus, bei denen diese über 75 liegt.

    \exampleseparator

    \begin{lstlisting}[style=SqlInputStyle]
        SELECT
            Typ,
            COUNT(*),
            MIN(Staerke),
            MAX(Staerke),
            AVG(Staerke)
        FROM attacke
        WHERE Staerke > 0
        GROUP BY Typ
        HAVING AVG(Staerke) > 75
        ORDER BY AVG(Staerke) DESC;
    \end{lstlisting}

    \begin{tabular}{I|TTTTT}
        \rowcolor{gray!35}  
        & \multicolumn{1}{T}{Typ} & \multicolumn{1}{T}{COUNT(*)} & \multicolumn{1}{T}{MIN(Staerke)} & \multicolumn{1}{T}{MAX(Staerke)} & \multicolumn{1}{T}{AVG(Staerke)} \\\hline
        1 & Feuer & 35 & 35 & 180 & 96.2857 \\ 
        2 & Psycho & 26 & 10 & 200 & 91.7308 \\
        3 & Drache & 22 & 10 & 185 & 91.1364 \\ 
        \multicolumn{1}{c|}{\dots} & \multicolumn{5}{c}{\dots} \\
        12 & Flug & 23 & 10 & 140 & 75.4348 \\
    \end{tabular}
\end{example}

\begin{bonus}{GROUP BY}
    Errechnen Sie

    \begin{itemize}
        \item Erwartungswert ($\mu$, E),
        \item Varianz ($\sigma^2$, Var), sowie
        \item Standardabweichung ($\sigma$, SD)
    \end{itemize}

    der jeweiligen nach Typ gruppierten Attacken.

    \exampleseparator

    \begin{lstlisting}[style=SqlInputStyle]
        SELECT
            Typ,
            ROUND(AVG(Staerke), 3) AS E,
            ROUND(AVG(POW(Staerke, 2)) - POW(AVG(Staerke), 2), 3) AS Var,
            ROUND(SQRT(AVG(POW(Staerke, 2)) - POW(AVG(Staerke), 2)), 3) AS SD
        FROM attacke
        GROUP BY Typ
        ORDER BY SD;
    \end{lstlisting}

    \begin{tabular}{I|TIII}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Typ} & \multicolumn{1}{T}{$\mu$} & \multicolumn{1}{T}{$\sigma^2$} & \multicolumn{1}{T}{$\sigma$} \\\hline
        1 & Käfer & 63.810 & 747.395 & 27.339 \\
        2 & Boden & 68.250 & 795.688 & 28.208 \\ 
        3 & Unlicht & 72.222 & 859.88 & 29.324 \\
        \multicolumn{1}{c|}{\dots} & \multicolumn{4}{c}{\dots} \\
        18 & Geist & 90.750 & 2633.188 & 51.315 \\
    \end{tabular}
\end{bonus}

\begin{example}{GROUP BY}
    Gruppieren Sie alle Pokémon nach Generation.
    Geben Sie diese Teilmengen sortiert nach Anzahl aus.
    Ermitteln Sie zusätzlich das gerundete Durchschnittsgewicht der Pokémon jeder Generation.

    \exampleseparator

    \begin{lstlisting}[style=SqlInputStyle]
SELECT
    Generation, COUNT(*), ROUND(AVG(Gewicht), 3)
FROM pokemon
GROUP BY Generation
ORDER BY COUNT(*);
    \end{lstlisting}

    \begin{tabular}{I|III}
        \rowcolor{gray!35}
        & \multicolumn{1}{T}{Generation} & \multicolumn{1}{T}{COUNT(*)} & \multicolumn{1}{T}{ROUND(AVG(Gewicht), 3)} \\\hline
        1 & 6 & 72 & 51.401 \\
        2 & 7 & 88 & 109.661 \\
        3 & 8 & 89 & 76.267 \\
        \multicolumn{1}{c|}{\dots} & \multicolumn{3}{c}{\dots} \\
        8 & 5 & 156 & 52.403 \\
    \end{tabular}
\end{example}